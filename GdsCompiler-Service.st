Object subclass: #GdsIoRecord	instanceVariableNames: 'kind desc session nSplit consume fragmentSize phase base64'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Service'!!GdsIoRecord commentStamp: 'kf 5/31/2009 23:05' prior: 0!A GdsIoRecord is xxxxxxxxx.Instance Variables	consume:		<Integer>	desc:		<Byte>	fragmentSize:		<Integer>	kind:		<Byte>	nSplit:		<Integer>	phase:		<Integer>	session:		<Integer>consume	- xxxxxdesc	- xxxxxfragmentSize	- xxxxxkind	- xxxxxnSplit	- xxxxxphase	- xxxxxsession	- xxxxx!!GdsIoRecord methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 14:56'!base64	^base64! !!GdsIoRecord methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 14:56'!base64: aString	base64 := aString.	fragmentSize := aString size.! !!GdsIoRecord methodsFor: 'as yet unclassified' stamp: 'kf 5/31/2009 23:34'!byteArray: aByteArray	| stream  |	self assert: aByteArray size = 2000.	stream := aByteArray readStream.	phase := stream next.	kind := stream next.	desc := stream next.	stream next. "padd"	session := stream nextInt32. 	nSplit := stream nextInt32.	consume := stream nextInt32.	fragmentSize := stream nextInt32.	base64 := (stream next: fragmentSize) asString	 ! !!GdsIoRecord methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 14:31'!consume: aNumber	consume := aNumber	 ! !!GdsIoRecord methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 15:47'!contentsOn: aWriteStream	| fillSize |	self headerOn: aWriteStream.	aWriteStream nextPutAll: self base64 asByteArray.	fillSize := self class bufferSize - (self class headerSize + fragmentSize).	fillSize timesRepeat: [aWriteStream nextPut:0 ].	 ! !!GdsIoRecord methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 15:42'!headerOn: aWriteStream	aWriteStream nextPut: phase.	aWriteStream nextPut: kind.	aWriteStream nextPut: desc.	aWriteStream nextPut: 0.	aWriteStream nextInt32Put: session.	aWriteStream nextInt32Put: nSplit.	aWriteStream nextInt32Put: consume.	aWriteStream nextInt32Put: fragmentSize.	 ! !!GdsIoRecord methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 14:21'!initialize	phase := self sessionRunLoop .	kind := self typeNormal.	desc := 1.	session := 1.	nSplit := 1.	consume := 1.	fragmentSize := 0.	base64 := ''.	 ! !!GdsIoRecord methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 15:08'!nSplit: aNumber	nSplit := aNumber! !!GdsIoRecord methodsFor: 'as yet unclassified' stamp: 'kf 5/31/2009 18:29'!session	^session! !!GdsIoRecord methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 14:21'!session: aNumber	session := aNumber	 ! !!GdsIoRecord methodsFor: 'testing' stamp: 'kf 5/31/2009 18:23'!hasMoreData	^consume < nSplit ! !!GdsIoRecord methodsFor: 'testing' stamp: 'kf 6/3/2009 14:11'!isSessionEnter	^ phase = self sessionEnter! !!GdsIoRecord methodsFor: 'testing' stamp: 'kf 6/3/2009 14:11'!isSessionExit	^ phase = self sessionExit! !!GdsIoRecord methodsFor: 'testing' stamp: 'kf 6/1/2009 14:17'!isTypeNormal	^kind =  self typeNormal! !!GdsIoRecord methodsFor: 'testing' stamp: 'kf 6/1/2009 14:17'!isTypePrompt	^kind = self typePrompt! !!GdsIoRecord methodsFor: 'testing' stamp: 'kf 6/1/2009 14:17'!isTypePromptReply	^kind =  self typePromptReply! !!GdsIoRecord methodsFor: 'testing' stamp: 'kf 6/1/2009 14:18'!sessionEnter	^1! !!GdsIoRecord methodsFor: 'testing' stamp: 'kf 6/1/2009 14:18'!sessionExit	^2! !!GdsIoRecord methodsFor: 'testing' stamp: 'kf 6/1/2009 14:18'!sessionRunLoop	^0! !!GdsIoRecord methodsFor: 'testing' stamp: 'kf 6/8/2009 14:52'!type: aInteger	({ self typeNormal . self typePrompt . self typePromptReply . self typeCodeComplete}		includes: aInteger)		ifFalse: [^self error: 'invarid argument for #type:'].	kind := aInteger! !!GdsIoRecord methodsFor: 'testing' stamp: 'kf 6/8/2009 13:24'!typeCodeComplete	^3! !!GdsIoRecord methodsFor: 'testing' stamp: 'kf 6/1/2009 14:16'!typeNormal	^0! !!GdsIoRecord methodsFor: 'testing' stamp: 'kf 6/1/2009 14:16'!typePrompt	^1! !!GdsIoRecord methodsFor: 'testing' stamp: 'kf 6/1/2009 14:16'!typePromptReply	^2! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsIoRecord class	instanceVariableNames: ''!!GdsIoRecord class methodsFor: 'constants' stamp: 'kf 6/1/2009 14:04'!bufferSize	^2000! !!GdsIoRecord class methodsFor: 'constants' stamp: 'kf 6/1/2009 14:04'!headerSize	^20! !!GdsIoRecord class methodsFor: 'accessing' stamp: 'kf 6/1/2009 14:04'!fragmentSize	^self bufferSize - self headerSize ! !!GdsIoRecord class methodsFor: 'instance creation' stamp: 'kf 5/31/2009 18:01'!fromByteArray: aByteArray	^self new byteArray: aByteArray! !GdsIoRecord subclass: #GdsIoRecive	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Service'!!GdsIoRecive methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 00:06'!asString	^ GdsServer chomp: (Base64MimeConverter		mimeDecodeToChars: (ReadStream on: base64)) contents! !!GdsIoRecive methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 00:05'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream print: self asString.	aStream nextPut: $).		! !GdsIoRecord subclass: #GdsIoReply	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Service'!!GdsIoReply methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 15:48'!contents	| s |	s := WriteStream on: (ByteArray new: self class bufferSize).	self contentsOn: s.	^s contents.	! !!GdsIoReply methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 14:50'!message: aString	self base64: (Base64MimeConverter		mimeDecodeToBytes: (ReadStream on: aString)) contents.			! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsIoReply class	instanceVariableNames: ''!!GdsIoReply class methodsFor: 'as yet unclassified' stamp: 'kf 6/8/2009 14:12'!consume: aindex  base64: aString	| reply |	reply := self  new.	reply consume: aindex.	reply base64: aString.	^reply	 ! !Object subclass: #GdsIoSession	instanceVariableNames: 'session records'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Service'!!GdsIoSession commentStamp: 'kf 5/31/2009 23:05' prior: 0!A GdsIoSession is xxxxxxxxx.Instance Variables	records:		<OrderedCollection>	session:		<Integer>records	- xxxxxsession	- xxxxx!!GdsIoSession methodsFor: 'as yet unclassified' stamp: 'kf 5/31/2009 18:32'!addRecord: aGdsIoRecord	records ifNil: [records := OrderedCollection new].	records add: aGdsIoRecord.	! !!GdsIoSession methodsFor: 'as yet unclassified' stamp: 'kf 6/3/2009 14:15'!asString	records ifEmpty: [^''].	records size = 1 		ifTrue: [^records first asString].	^(records collect: [:each | each asString ]) joinUsing: String cr.! !!GdsIoSession methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 13:51'!hasMoreData	^records  last hasMoreData! !!GdsIoSession methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 14:30'!initialize	super initialize.	records := OrderedCollection new.	! !!GdsIoSession methodsFor: 'as yet unclassified' stamp: 'kf 6/1/2009 11:28'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	records size = 1 		ifTrue: [aStream print: records first asString ].	aStream nextPut: $).	! !!GdsIoSession methodsFor: 'as yet unclassified' stamp: 'kf 5/31/2009 18:25'!session	^session	! !!GdsIoSession methodsFor: 'as yet unclassified' stamp: 'kf 5/31/2009 18:25'!session: aNumber	session := aNumber 	! !GdsIoSession subclass: #GdsRecieveSession	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Service'!GdsIoSession subclass: #GdsReplySession	instanceVariableNames: 'isPrompt isCodeComplete'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Service'!!GdsReplySession methodsFor: 'initialize-release' stamp: 'kf 6/8/2009 14:07'!initialize	super initialize.	isPrompt  := false.	isCodeComplete := false.! !!GdsReplySession methodsFor: 'testing' stamp: 'kf 6/8/2009 14:07'!isCodeComplete	^isCodeComplete! !!GdsReplySession methodsFor: 'testing' stamp: 'kf 6/5/2009 16:14'!isPrompt	^isPrompt! !!GdsReplySession methodsFor: 'accessing' stamp: 'kf 6/1/2009 15:17'!message	| stream |	stream := WriteStream on: (String new: 4096).	records do: [:each |		stream nextPutAll: each base64].	^(Base64MimeConverter		mimeDecodeToChars: stream contents readStream) contents	! !!GdsReplySession methodsFor: 'accessing' stamp: 'kf 6/8/2009 14:16'!message: aString	| base64 nSplit unit rest start end fragment reply consume |	records := OrderedCollection new.	base64 := (Base64MimeConverter		mimeEncode: (ReadStream on: aString)) contents.		unit := GdsIoReply fragmentSize.	nSplit := base64 size // unit.	rest := base64 size \\ unit.	consume := 1.	1 to: nSplit do: [:index |		start := (index - 1) * unit + 1.		end := start + unit - 1.		fragment := base64 copyFrom: start to: end .		reply := GdsIoReply consume: index base64: fragment.		self addRecord: reply.		consume := consume + 1].		rest > 0		ifTrue: [			nSplit := nSplit + 1.			reply := GdsIoReply consume:  consume base64: (base64 last: rest).			self addRecord: reply.].	records 		ifEmpty: [			reply := GdsIoReply consume:  consume base64: ''.			self addRecord: reply.].	self setSplitNumber: nSplit.! !!GdsReplySession methodsFor: 'accessing' stamp: 'kf 6/8/2009 14:06'!setCodeCompleteState: aBoolean	isCodeComplete := aBoolean.	! !!GdsReplySession methodsFor: 'accessing' stamp: 'kf 6/5/2009 16:12'!setPrommptState: aBoolean	isPrompt := aBoolean.	! !!GdsReplySession methodsFor: 'accessing' stamp: 'kf 6/8/2009 14:15'!setSplitNumber: nSplit	records do: [:each | 		each session: self session.		self isPrompt 			ifTrue: [				each type: each typePrompt].		self isCodeComplete  			ifTrue: [				each type: each typeCodeComplete ].		each nSplit: nSplit].! !!GdsReplySession methodsFor: 'action' stamp: 'kf 6/8/2009 17:11'!send: aSocket	| data |	self assert: [records isEmpty not].	records do: [:each |		data := each contents .		"data explore."		aSocket sendData: data].	records := nil.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsReplySession class	instanceVariableNames: ''!TcpService subclass: #GdsServer	instanceVariableNames: 'evaluter sessionMap'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Service'!!GdsServer commentStamp: 'kf 5/31/2009 23:06' prior: 0!A GdsServer is xxxxxxxxx.Instance Variables	evaluter:		<GplEvaluter>	sessionMap:		<Dictionary<Integer,GdsIoSession>>evaluter	- xxxxxsessionMap	- xxxxx!!GdsServer methodsFor: 'conversation' stamp: 'kf 6/6/2009 11:06'!clearSession	sessionMap := nil.	evaluter flushContextStacks.		! !!GdsServer methodsFor: 'conversation' stamp: 'kf 6/6/2009 11:06'!endSession	self clearSession		! !!GdsServer methodsFor: 'conversation' stamp: 'kf 6/8/2009 14:01'!getReciveSession: aGdsInRecord	| session |	session := self sessionOfNumber: aGdsInRecord session.	session addRecord: aGdsInRecord.	^session! !!GdsServer methodsFor: 'conversation' stamp: 'kf 9/8/2012 16:04'!implementedMethodNames	| col |	col := OrderedCollection new.	col addAll: GplHandler commandNames.	col addAll: GplToken implementedMonadicMethods.	col addAll: GplToken implementedDyadicMethods.	^col asSet asArray.! !!GdsServer methodsFor: 'conversation' stamp: 'kf 6/5/2009 17:38'!send: aString on: aSocket	aSocket sendData: ((self class chomp: aString), self class eoString) .	self debugLog: (self class chomp: aString).! !!GdsServer methodsFor: 'conversation' stamp: 'kf 6/5/2009 15:00'!serve: aSocket 	| reciveData bytes |	reciveData := aSocket receiveData. 	bytes := reciveData asByteArray.	"self halt."	(bytes isEmpty not and: [(#(0 1 2) includes: (bytes first))]) 		ifTrue: [self serveNew: aSocket reciveData: reciveData]		ifFalse: [self serveClassic: aSocket reciveData: reciveData].! !!GdsServer methodsFor: 'conversation' stamp: 'kf 6/5/2009 17:41'!serveClassic: aSocket reciveData: reciveData	| data |	data := self class chomp: reciveData.	data ifEmpty: [^self].	self debugLog: (Time now printString, ': ' ,'<',data,'>').	[| reply | 	  reply := evaluter evaluteConsoleLine: data.	 self send: reply on: aSocket .]		on: Error do: [:ex | self send: ex asString on: aSocket].! !!GdsServer methodsFor: 'conversation' stamp: 'kf 6/10/2009 16:50'!serveNew: aSocket reciveData: reciveData 	| ioForInspect session replySession reply isPrompt arg evaluteBlock |	ioForInspect := GdsIoRecive fromByteArray: reciveData asByteArray.	ioForInspect isSessionEnter		ifTrue: [^ self startSession: aSocket].						ioForInspect isSessionExit		ifTrue: [^ self endSession].			session := self getReciveSession: ioForInspect.	session hasMoreData ifTrue: [^ self].	arg := session asString.	evaluteBlock := [:arg1 | evaluter evaluteConsoleLine: arg1].	ioForInspect isTypePromptReply 		ifTrue: [ 			evaluter pushResult:  session asString.			evaluteBlock := [:arg1 | 				evaluter evaluteAsString: [evaluter resume]]].	replySession := GdsReplySession new session: session session.	isPrompt := false.	self debugLog: Time now printString , ': ' , '<' , arg asString, '>'.	reply := [evaluteBlock value: arg] on: Error				do: 					[:ex | 					(ex isKindOf: GplPromptException) 						ifTrue: 							[isPrompt := true.							ex messageText]						ifFalse: [ex asString]].	reply isNil ifTrue: [reply := ''].	self debugLog: Time now printString , ': ' , '[' , reply , ']'.	replySession setPrommptState: isPrompt.	replySession message: reply.	self 		debugLog: Time now printString , ': ' , '(' , replySession message , ')'.	replySession send: aSocket! !!GdsServer methodsFor: 'conversation' stamp: 'kf 6/8/2009 14:50'!startSession: aSocket	| replySession |	self clearSession.	replySession := GdsReplySession new session: 0.	replySession setCodeCompleteState: true.	replySession message: 		(self implementedMethodNames joinUsing: String cr).	replySession send: aSocket	! !!GdsServer methodsFor: 'conversation' stamp: 'kf 6/6/2009 11:12'!suspendedGplExpressionLateResult: aResult 	| context suspendToken |	"self halt."	evaluter pushResult: aResult.	context := evaluter peekSuspendContext.	suspendToken := context tempAt: 1.	self assert: (suspendToken isMemberOf: GplToken).	^ suspendToken parser source! !!GdsServer methodsFor: 'accessing' stamp: 'kf 6/5/2009 17:46'!debugLog: aObject	evaluter debugLog: aObject.! !!GdsServer methodsFor: 'accessing' stamp: 'kf 5/31/2009 18:27'!sessionOfNumber: aNumber	sessionMap ifNil: [sessionMap := Dictionary new].	^sessionMap at: aNumber ifAbsentPut: [GdsIoSession new session: aNumber].	! !!GdsServer methodsFor: 'accessing' stamp: 'kf 5/21/2009 17:29'!showsLog	^evaluter showsLog! !!GdsServer methodsFor: 'accessing' stamp: 'kf 5/21/2009 17:29'!showsLog: aBoolean	evaluter showsLog: aBoolean! !!GdsServer methodsFor: 'initialization' stamp: 'kf 4/22/2009 00:22'!initialize	super initialize.	evaluter := GplEvaluter new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsServer class	instanceVariableNames: 'server'!!GdsServer class methodsFor: 'convert' stamp: 'kf 6/8/2009 17:12'!chomp: aString	| lastIndex index|	aString isEmpty ifTrue: [^''].	lastIndex :=  aString size.	index := lastIndex.	[index >= 1]		whileTrue: [			| c |			c := aString at: index.			((c = Character lf) or: [c = Character cr])				ifFalse: [^aString copyFrom: 1 to: index].			index := index - 1.].	^aString.! !!GdsServer class methodsFor: 'constant' stamp: 'kf 4/23/2009 10:44'!eoString	^(Character value: 0) asString! !!GdsServer class methodsFor: 'accessing' stamp: 'kf 5/21/2009 17:30'!showsLog: aBoolean	server ifNotNil: [server showsLog: aBoolean].! !!GdsServer class methodsFor: 'accessing' stamp: 'kf 4/23/2009 13:54'!start	server ifNotNil: [		Transcript cr; show: '!!!!!! Server already running !!!!!!'. 		^self]. 	server := self startOn: 9999 named: 'gds'.	! !!GdsServer class methodsFor: 'accessing' stamp: 'kf 4/23/2009 13:56'!stop	server ifNil: [		Transcript cr; show: '!!!!!! Server already stopped !!!!!!'. 		^self]. 	server stop.	server := nil.	! !