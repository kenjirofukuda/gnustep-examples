Object subclass: #GdsInform	instanceVariableNames: 'reader stderr stdout library'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Developer-IO'!!GdsInform commentStamp: 'kf 10/23/2009 05:39' prior: 0!A GdsInform is INFORM command handler.Instance Variables	library:		<GdsLibrary>	reader:		<GdsStreamFormatReader>	stderr:		<GdsLog>	stdout:		<GdsLog>library	- xxxxxreader	- xxxxxstderr	- xxxxxstdout	- xxxxx!!GdsInform methodsFor: 'as yet unclassified' stamp: 'kf 10/21/2009 15:03'!readHeader	| header |	header := reader nextRecord.	header 		ifNil: [			self abort: 'HEADER is missing. Aborting'].! !!GdsInform methodsFor: 'as yet unclassified' stamp: 'kf 10/27/2009 10:30'!readPrimitiveBegin: element	|  record |	record := reader nextRecord.	#LAYER = record type		ifFalse: [^self abort: (self missingField:  record type ofElement: element)].	element layerNumber: record int2.	record := reader nextRecord.	#DATATYPE = record type		ifFalse: [^self abort: (self missingField:  record type ofElement: element)].	element datatype: record int2.! !!GdsInform methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 22:58'!readPrimitiveEnd: element	|  record  points |	record := reader nextRecord.	#XY = record type		ifFalse: [^self abort: (self missingField:  record type ofElement: element)].	points := record pointsScaledBy: library userUnit .	element vertices: points.		record := reader nextRecord.	#ENDEL = record type		ifFalse: [^self abort: (self missingField:  record type ofElement: element)].! !!GdsInform methodsFor: 'as yet unclassified' stamp: 'kf 10/22/2009 15:43'!readStruct	| break record structure result |		record := reader nextRecord.	#BGNSTR = record type		ifFalse: [			reader unreadRecord: record.			record := reader nextRecord.			#ENDLIB = record type				ifTrue: [^nil]				ifFalse:[					self abort: 'Missing ENDLIB field. Abort!!']].	structure := GdsStructure new.		break := false.	[break ifFalse: [record := reader nextRecord].	break or: [record isNil]]		whileFalse: [			result := self readStruct: record structure: structure.			break := result first.			break ifTrue: [^result last]].	^nil.	! !!GdsInform methodsFor: 'as yet unclassified' stamp: 'kf 11/10/2009 10:26'!readStruct: aRecord structure: aGdsStructure	| result result2 |	result := {false . nil}.	#STRNAME = aRecord type		ifTrue: [ | name|			name := aRecord asString.			aGdsStructure setName: name.			self stdout: ('strname = {1}' format: {name}).			^result].	aRecord  isElementHeader 		ifTrue: [ | sel newElement |			(GdsElement installedElementType: aRecord type)				ifTrue: [					sel := ('read{1}:' format: {aRecord type asString}) asSymbol.					result2 := self perform: sel with: aGdsStructure.					newElement := result2 last.					newElement ifNotNil: [aGdsStructure addElement: newElement].					^{false .  aGdsStructure}]].	#ENDSTR = aRecord type		ifTrue: [^{true . aGdsStructure}].	((#BGNSTR = aRecord type) or: [#ENDLIB = aRecord type])		ifTrue: [			self stderr: 'Incorrect record type in #readStruct'.			^{true . nil}].	^result													! !!GdsInform methodsFor: 'as yet unclassified' stamp: 'kf 10/21/2009 20:34'!readUpToFirstStruct	| break record |	break := false.	record := nil.	[break 		ifFalse: [		record := reader nextRecord].	break  or: [record isNil]]		whileFalse: [			break := self readUpToFirstStructRecord: record]! !!GdsInform methodsFor: 'as yet unclassified' stamp: 'kf 10/24/2009 15:41'!readUpToFirstStructRecord: aRecord	| items libname |	#BGNLIB = aRecord type 		ifTrue: [			library := GdsLibrary new.			items := aRecord dateAndTimes.			library lastModified: items first.			library lastAccessed: items second.			^false].	#LIBNAME = aRecord type		ifTrue: [			libname := aRecord asString.			libname isEmptyOrNil ifTrue: [self abort: 'Bad LIBNAME record. Aborting'].			library libName: libname.			^false].	#UNITS = aRecord type		ifTrue: [			items := aRecord real8Array.			library userUnit: items first.			library meterUnit: items second.			^false].	#BGNSTR = aRecord type		ifTrue: [			reader unreadRecord: aRecord.			^true].			(self cantHandledTypes  includes: aRecord type)		ifTrue: [			self stderr: ('Not yet handling {1}' format: {aRecord type asString})].	^false! !!GdsInform methodsFor: 'element reader' stamp: 'kf 11/10/2009 10:29'!readAREF: aGdsStructure	| loopContext  element record clazz  |	clazz := GdsElement classForType: #aref.	clazz ifNil: [^{false . nil }].	element := clazz new.		loopContext := GdsStreamLoopContext new.	loopContext setInform: self.	loopContext structure: aGdsStructure.	loopContext element: element.	loopContext setupAREFkeys.	loopContext result: {false . nil }.	[loopContext break ifFalse: [record := reader nextRecord].	loopContext break or: [record isNil]]		whileFalse: [			loopContext switchAREF: record].	^loopContext result.! !!GdsInform methodsFor: 'element reader' stamp: 'kf 11/10/2009 10:31'!readBOUNDARY:  aGdsStructure	| element loopContext record clazz |	clazz := GdsElement classForType: #boundary.	clazz ifNil: [^{false . nil }].	element := clazz new.	loopContext := GdsStreamLoopContext new.	loopContext setInform: self.	loopContext structure: aGdsStructure.	loopContext element: element.	loopContext setupBOUNDARYkeys.	loopContext result: {false . nil }.	[loopContext break ifFalse: [record := reader nextRecord].	loopContext break or: [record isNil]]		whileFalse: [			loopContext switchBOUNDARY: record].	^loopContext result.! !!GdsInform methodsFor: 'element reader' stamp: 'kf 10/24/2009 17:14'!readBOX: aGdsStructure	"FIXME: "	^{false . nil}																	! !!GdsInform methodsFor: 'element reader' stamp: 'kf 10/24/2009 17:14'!readNODE: aGdsStructure	"FIXME: "	^{false . nil}																	! !!GdsInform methodsFor: 'element reader' stamp: 'kf 11/10/2009 10:32'!readPATH:  aGdsStructure	| element record loopContext clazz |	clazz := GdsElement classForType: #path.	clazz ifNil: [^{false . nil }].	element := clazz new.	loopContext := GdsStreamLoopContext new.	loopContext setInform: self.	loopContext structure: aGdsStructure.	loopContext element: element.	loopContext setupPATHkeys.	loopContext result: {false . nil }.	[loopContext break ifFalse: [record := reader nextRecord].	loopContext break or: [record isNil]]		whileFalse: [			loopContext switchPATH: record].	^loopContext result.! !!GdsInform methodsFor: 'element reader' stamp: 'kf 11/10/2009 10:32'!readSREF: aGdsStructure	| loopContext  element record  clazz |	clazz := GdsElement classForType: #sref.	clazz ifNil: [^{false . nil }].	element := clazz new.	loopContext := GdsStreamLoopContext new.	loopContext setInform: self.	loopContext structure: aGdsStructure.	loopContext element: element.	loopContext setupSREFkeys.	loopContext result: {false . nil }.	[loopContext break ifFalse: [record := reader nextRecord].	loopContext break or: [record isNil]]		whileFalse: [			loopContext switchSREF: record].	^loopContext result.! !!GdsInform methodsFor: 'element reader' stamp: 'kf 10/24/2009 17:21'!readTEXT: aGdsStructure	"FIXME: "	^{false . nil}																	! !!GdsInform methodsFor: 'private' stamp: 'kf 10/21/2009 15:03'!abort: aString	self stderr: aString.	self error: aString	! !!GdsInform methodsFor: 'private' stamp: 'kf 10/21/2009 15:17'!cantHandledTypes	^#(LIBDIRSIZE SRFNAME LIBSECUR REFLIBS FONTS)! !!GdsInform methodsFor: 'private' stamp: 'kf 10/21/2009 17:30'!missingField: aSymbol ofElement: aGdsElement	| elementTypeString |	elementTypeString := aGdsElement.	(elementTypeString isKindOf: GdsElement)		ifTrue: [elementTypeString := elementTypeString typeString].	^'Missing {1} Field in {1} element. Abort!!' format: {aSymbol asString . elementTypeString}											! !!GdsInform methodsFor: 'private' stamp: 'kf 10/21/2009 15:00'!stderr: aString	stderr println: aString.	! !!GdsInform methodsFor: 'private' stamp: 'kf 10/21/2009 15:00'!stdout: aString	stdout println: aString.	! !!GdsInform methodsFor: 'service' stamp: 'kf 10/21/2009 20:05'!readLib	| structure |	reader reset.	self readHeader.	self readUpToFirstStruct.	[structure := self readStruct.	structure isNil]		whileFalse: [			library addStructure: structure.]	! !!GdsInform methodsFor: 'service' stamp: 'kf 10/22/2009 16:36'!run	self readLib.	self saveLibrary.	! !!GdsInform methodsFor: 'service' stamp: 'kf 11/9/2009 20:37'!saveLibrary	library ifNil: [^self].	(GdsLibrary exists: library libName)		ifTrue: [^self inform: 'Already exist.'].	self saveLibraryWithArchive: true.! !!GdsInform methodsFor: 'service' stamp: 'kf 11/18/2009 17:11'!saveLibraryWithArchive: aBoolean	library unitString: 'MICRON'. "TODO: fix"		library makeFolder.	library structures do: [:each | each fileOutAsXml].	library autoAllocateLayerColors.	"library layers explore."	aBoolean ifTrue: [library close].! !!GdsInform methodsFor: 'initialization' stamp: 'kf 10/21/2009 20:28'!initialize	super initialize.	stderr := GdsLog new category: 'stderr'.	stderr beginLog.	stdout := GdsLog new category: 'stdout'.		stdout beginLog.! !!GdsInform methodsFor: 'accessing' stamp: 'kf 10/23/2009 21:56'!library	^library! !!GdsInform methodsFor: 'accessing' stamp: 'kf 10/21/2009 14:36'!reader: aGdsStreamFormatReader	reader := aGdsStreamFormatReader.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsInform class	instanceVariableNames: ''!!GdsInform class methodsFor: 'as yet unclassified' stamp: 'kf 11/18/2009 16:23'!downloadSample	"self downloadSample"	| fileName zipPath archiver extractedFd |	fileName := self urlForZipedGDSreaderArchive asUrl path last.	zipPath := GdsFeel fileDirectory fullNameFor: fileName. 	(FileDirectory default fileExists: zipPath)		ifFalse:  [			self downloadUrl: self urlForZipedGDSreaderArchive  toFileNamed: zipPath].	(FileDirectory default fileExists: zipPath)		ifFalse:  [			^self inform: 'Download Fail'].			(ZipArchive isZipArchive: zipPath)		ifFalse: [^self inform: ('Not a Zip File {1}' format: {zipPath})].			archiver := ZipArchive new.	archiver readFrom: zipPath.	extractedFd := GdsFeel fileDirectory.	extractedFd assureExistence.	archiver extractAllTo: extractedFd .	archiver close.		! !!GdsInform class methodsFor: 'as yet unclassified' stamp: 'kf 11/18/2009 16:19'!downloadUrl: aUrl toFileNamed: aFullPath	| stream |	stream := nil.	[stream := aUrl asUrl retrieveContents contentStream binary.]		on: Error do: [:ex | ^Transcript cr; show: 'Download Error'].	stream ifNil: [^self].	StandardFileStream 		forceNewFileNamed: aFullPath 		do: [:newStream |			newStream binary.			newStream nextPutAll: stream contents].! !!GdsInform class methodsFor: 'as yet unclassified' stamp: 'kf 11/24/2009 11:21'!makeGDSreaderSample	"self makeGDSreaderSample"	| inst reader pathToSample |	pathToSample := self pathToStreamFormatSample.	(FileDirectory default fileExists: pathToSample)		ifFalse: [ self downloadSample ].	(FileDirectory default fileExists: pathToSample) 		ifFalse: [ ^ self inform: 'Sample file not found' ].	reader := GdsStreamFormatReader instanceOfPath: pathToSample.	reader ifNil: [ ^ self ].	inst := GdsInform new reader: reader.	Cursor wait showWhile: [ inst run ]! !!GdsInform class methodsFor: 'as yet unclassified' stamp: 'kf 11/18/2009 21:44'!pathToStreamFormatSample	^{(GdsFeel fileDirectory fullNameFor: 'GDSreader.0.3.2') . 'test.gds'} 		joinUsing: FileDirectory slash asString.! !!GdsInform class methodsFor: 'as yet unclassified' stamp: 'kf 11/9/2009 10:53'!urlForZipedGDSreaderArchive	^'http://gdsfeel.com/downloads/GDSreader.0.3.2.zip'.! !Object subclass: #GdsLoopContext	instanceVariableNames: 'break result'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Developer-IO'!!GdsLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 22:42'!break	^break	! !!GdsLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 05:49'!break: aBoolean	break := aBoolean	! !!GdsLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 06:15'!initialize	super initialize.	break := false.! !!GdsLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 21:59'!result	^result	! !!GdsLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 22:00'!result: anObject	result := anObject	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsLoopContext class	instanceVariableNames: ''!Object subclass: #GdsStreamFormatReader	instanceVariableNames: 'stream'	classVariableNames: 'TypeCodeMap'	poolDictionaries: ''	category: 'GdsFeel-Developer-IO'!!GdsStreamFormatReader commentStamp: 'kf 10/23/2009 05:39' prior: 0!A GdsStreamFormatReader is xxxxxxxxx.Instance Variables	stream:		<StanderedFileStream>stream	- dont use MultiByteFileStream.!!GdsStreamFormatReader methodsFor: 'as yet unclassified' stamp: 'kf 10/21/2009 14:33'!allRecords	| col |	col := OrderedCollection new.	self allRecordsDo: [:each | col add: each].	^col asArray.	! !!GdsStreamFormatReader methodsFor: 'as yet unclassified' stamp: 'kf 10/22/2009 14:12'!allRecordsDo: aBlock	| record |	self reset.	record := nil.	[record := self nextRecord.	record isNil]		whileFalse: [						aBlock value: record].	! !!GdsStreamFormatReader methodsFor: 'as yet unclassified' stamp: 'kf 10/22/2009 14:31'!nextByteArray	| restSize bytes recordSize |	recordSize := self recordSize.	recordSize < 0 ifTrue: [^nil].	restSize := recordSize - 2.	recordSize <= 0 ifTrue: [^nil].		bytes := (stream next: restSize) asByteArray.	^bytes! !!GdsStreamFormatReader methodsFor: 'as yet unclassified' stamp: 'kf 10/22/2009 14:33'!nextRecord	"^[GdsStreamRecord new bytes: self nextByteArray] on: Error do: [:ex | nil]."	| bytes |	bytes := self nextByteArray.	bytes ifNil:  [^nil].	bytes ifEmpty: [^nil].	^GdsStreamRecord new bytes: bytes.! !!GdsStreamFormatReader methodsFor: 'as yet unclassified' stamp: 'kf 10/22/2009 14:29'!recordSize	| buff |	stream atEnd ifTrue: [^-1].	buff := (stream next: 2) asByteArray.	^buff  unsignedShortAt: 1 bigEndian: true.! !!GdsStreamFormatReader methodsFor: 'as yet unclassified' stamp: 'kf 10/22/2009 14:21'!reset	stream reset.	self assert: [stream position = 0].! !!GdsStreamFormatReader methodsFor: 'as yet unclassified' stamp: 'kf 10/20/2009 14:29'!stream: aStream	stream := aStream.	! !!GdsStreamFormatReader methodsFor: 'as yet unclassified' stamp: 'kf 10/21/2009 20:24'!unreadRecord: aGdsStreamRecord	self unreadSize: (aGdsStreamRecord countBytes + 2).! !!GdsStreamFormatReader methodsFor: 'as yet unclassified' stamp: 'kf 10/21/2009 15:09'!unreadSize: aInteger	stream skip: aInteger negated.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsStreamFormatReader class	instanceVariableNames: ''!!GdsStreamFormatReader class methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 23:28'!chooseSampleFile	"self chooseSampleFile"	| fd |	fd := FileList2 modalFileSelectorForSuffixes:  #('gds' 'cal').	fd ifNil: [^nil].	^fd		! !!GdsStreamFormatReader class methodsFor: 'as yet unclassified' stamp: 'kf 10/21/2009 19:49'!example	"self example"	|inst |	inst := self exampleInstance.	^inst allRecords. 		! !!GdsStreamFormatReader class methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 11:28'!exampleInstance	"self exampleInstance"	| fd |	fd := self chooseSampleFile.	fd ifNil: [^nil.].	^self instanceOfPath: fd fullName.		! !!GdsStreamFormatReader class methodsFor: 'as yet unclassified' stamp: 'kf 10/20/2009 13:35'!initialize	"self initialize"	TypeCodeMap := self lookupTypeCodeMap.	! !!GdsStreamFormatReader class methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 11:23'!instanceOfPath: aString	"self exampleInstance"	|inst |	inst := self new stream: (StandardFileStream readOnlyFileNamed: aString).	^inst		! !!GdsStreamFormatReader class methodsFor: 'as yet unclassified' stamp: 'kf 10/20/2009 13:34'!lookupTypeCodeMap	| map |	map := Dictionary new.	self spec do: [:each |		map at: each first put:  each second].	^map! !!GdsStreamFormatReader class methodsFor: 'as yet unclassified' stamp: 'kf 10/20/2009 10:05'!spec^{#(16r00 HEADER) . #(16r01 BGNLIB) . #(16r02 LIBNAME) . #(16r03 UNITS) . #(16r04 ENDLIB) . #(16r05 BGNSTR) . #(16r06 STRNAME) . #(16r07 ENDSTR) . #(16r08 BOUNDARY) . #(16r09 PATH) . #(16r0A SREF) . #(16r0B AREF) . #(16r0C TEXT) . #(16r0D LAYER) . #(16r0E DATATYPE) . #(16r0F WIDTH) . #(16r10 XY) . #(16r11 ENDEL) . #(16r12 SNAME) . #(16r13 COLROW) . #(16r14 TEXTNODE) . #(16r15 NODE) . #(16r16 TEXTTYPE) . #(16r17 PRESENTATION) . #(16r18 SPACING) . #(16r19 STRING) . #(16r1A STRANS) . #(16r1B MAG) . #(16r1C ANGLE) . #(16r1D UINTEGER) . #(16r1E USTRING) . #(16r1F REFLIBS) . #(16r20 FONTS) . #(16r21 PATHTYPE) . #(16r22 GENERATIONS) . #(16r23 ATTRTABLE) . #(16r24 STYPTABLE) . #(16r25 STRTYPE) . #(16r26 ELFLAGS) . #(16r27 ELKEY) . #(16r28 LINKTYPE) . #(16r29 LINKKEYS) . #(16r2A NODETYPE) . #(16r2B PROPATTR) . #(16r2C PROPVALUE) . #(16r2D BOX) . #(16r2E BOXTYPE) . #(16r2F PLEX) . #(16r30 BGNEXTN) . #(16r31 ENDTEXTN) . #(16r32 TAPENUM) . #(16r33 TAPECODE) . #(16r34 STRCLASS) . #(16r35 RESERVED) . #(16r36 FORMAT) . #(16r37 MASK) . #(16r38 ENDMASKS) . #(16r39 LIBDIRSIZE) . #(16r3A SRFNAME) . #(16r3B LIBSECUR)  }! !!GdsStreamFormatReader class methodsFor: 'as yet unclassified' stamp: 'kf 10/20/2009 13:38'!typeForCode: aByte	^TypeCodeMap at: aByte ifAbsent: [#UNKOWN]	! !GdsLoopContext subclass: #GdsStreamLoopContext	instanceVariableNames: 'element structure countMap typeOrder inform'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Developer-IO'!!GdsStreamLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 09:06'!addOptional: aSymbol	typeOrder add: {#optional . aSymbol}.	self using: aSymbol.! !!GdsStreamLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 09:07'!addRequired: aSymbol	typeOrder add: {#required . aSymbol}.	self using: aSymbol.	! !!GdsStreamLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 09:35'!checkPreRequiredConsumed: aSymbol	self checkPreRequiredConsumed: aSymbol abort: true! !!GdsStreamLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 11:45'!checkPreRequiredConsumed: aSymbol abort: abort	|  preRequiredKeys |	preRequiredKeys := self preRequiredKeysFor: aSymbol.	preRequiredKeys do: [:each | 		(self hasEntry: each)			ifFalse: [|msg|				msg := (inform missingField: aSymbol ofElement: element).				inform stderr: msg.				abort ifTrue: [inform error: msg]]]! !!GdsStreamLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 06:05'!countOf: aSymbol	self using: aSymbol.	^countMap at: aSymbol! !!GdsStreamLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 11:38'!preRequiredKeysFor: aSymbol	| keys orderStream  |	keys := self requiredOrder.	(keys includes: aSymbol) ifFalse: [^#()].	orderStream := keys readStream.	^(orderStream upTo: aSymbol) allButLast.! !!GdsStreamLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 09:24'!requiredConsumed: aSymbol	| orderStream preRequiredKeys |	orderStream := self requiredOrder readStream.	preRequiredKeys := (orderStream upTo: aSymbol) allButLast.	^preRequiredKeys allSatisfy: [:each | self hasEntry: each]! !!GdsStreamLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 09:20'!requiredOrder	^typeOrder select: [:each | each first = #required] thenCollect: [:each | each second].! !!GdsStreamLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 06:04'!upCount: aSymbol	self using: aSymbol.	countMap at: aSymbol put: ((countMap at: aSymbol) + 1).! !!GdsStreamLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 06:03'!using: aSymbol	countMap at: aSymbol ifAbsentPut: [0].! !!GdsStreamLoopContext methodsFor: 'as yet unclassified' stamp: 'kf 10/23/2009 06:00'!usingCounts: aSymbolArray	aSymbolArray do: [:each |		self using: aSymbolArray].! !!GdsStreamLoopContext methodsFor: 'accessing' stamp: 'kf 10/23/2009 05:44'!element: aGdsElement	element := aGdsElement! !!GdsStreamLoopContext methodsFor: 'accessing' stamp: 'kf 10/23/2009 09:30'!setInform: aGdsInform	inform := aGdsInform! !!GdsStreamLoopContext methodsFor: 'accessing' stamp: 'kf 10/23/2009 05:45'!structure: aGdsStructure	structure := aGdsStructure! !!GdsStreamLoopContext methodsFor: 'testing' stamp: 'kf 10/23/2009 11:46'!hasEntry: aSymbol	^(self countOf: aSymbol) >= 1.! !!GdsStreamLoopContext methodsFor: 'initialization' stamp: 'kf 10/23/2009 06:22'!initialize	super initialize.	countMap := Dictionary new.	typeOrder := OrderedCollection new.! !!GdsStreamLoopContext methodsFor: 'key specs' stamp: 'kf 10/24/2009 16:16'!setupAREFkeys	"	FULL SPEC:	AREF [ELFLAGS] [PLEX] SNAME [STRANS [MAG] [ANGLE]] COLROW XY 	[PROPATTR PROPVALUE]* ENDEL		MINIMUM CASE:	SREF SNAME XY ENDEL	"	self addOptional: #ELFLAGS.	self addOptional: #PLEX.		self addRequired: #SNAME.		self addOptional: #STRANS.	self addOptional: #MAG.	self addOptional: #ANGLE.		self addRequired: #XY.		self addOptional: #PROPATTR.	self addOptional: #PROPVALUE.	self addRequired: #ENDEL.! !!GdsStreamLoopContext methodsFor: 'key specs' stamp: 'kf 10/24/2009 17:02'!setupBOUNDARYkeys	"	FULL SPEC: 	BOUNDARY [ELFLAGS] [PLEX] LAYER DATATYPE  XY [PROPATTR PROPVALUE]* ENDEL			MINIMUM CASE:	BOUNDARY  LAYER DATATYPE  XY ENDEL	"	self addOptional: #ELFLAGS.	self addOptional: #PLEX.		self addRequired: #LAYER.	self addRequired: #DATATYPE.		self addRequired: #XY.		self addOptional: #PROPATTR.	self addOptional: #PROPVALUE.		self addRequired: #ENDEL.! !!GdsStreamLoopContext methodsFor: 'key specs' stamp: 'kf 10/24/2009 17:01'!setupPATHkeys	"	FULL SPEC: 	PATH [ELFLAGS] [PLEX] LAYER DATATYPE [PATHTYPE][WIDTH] XY	[PROPATTR PROPVALUE]* ENDEL		MINIMUM CASE:	PATH  LAYER DATATYPE  XY ENDEL	"	self addOptional: #ELFLAGS.	self addOptional: #PLEX.		self addRequired: #LAYER.	self addRequired: #DATATYPE.		self addOptional: #PATHTYPE.	self addOptional: #WIDTH.		self addRequired: #XY.		self addOptional: #PROPATTR.	self addOptional: #PROPVALUE.		self addRequired: #ENDEL.! !!GdsStreamLoopContext methodsFor: 'key specs' stamp: 'kf 10/24/2009 15:39'!setupSREFkeys	"	FULL SPEC:	SREF [ELFLAGS] [PLEX] SNAME [STRANS [MAG] [ANGLE]] XY 	[PROPATTR PROPVALUE]* ENDEL		MINIMUM CASE:	SREF SNAME XY ENDEL	"	self addOptional: #ELFLAGS.	self addOptional: #PLEX.		self addRequired: #SNAME.		self addOptional: #STRANS.	self addOptional: #MAG.	self addOptional: #ANGLE.		self addRequired: #XY.		self addOptional: #PROPATTR.	self addOptional: #PROPVALUE.	self addRequired: #ENDEL.! !!GdsStreamLoopContext methodsFor: 'key specs' stamp: 'kf 10/24/2009 15:52'!setupTEXTkeys	"	FULL SPEC: 	TEXT [ELFLAGS] [PLEX] LAYER TEXTYPE [PRESENTATION] [PATHTYPE] [WIDTH] 	[STRANS [MAG] [ANGLE]] XY STRING 	[PROPATTR PROPVALUE]* ENDEL		MINIMUM SPEC:	TEXT  LAYER TEXTYPE  XY STRING ENDEL	"	self addOptional: #ELFLAGS.	self addOptional: #PLEX.		self addRequired: #LAYER.	self addRequired: #TEXTTYPE. "NOT #DATATYPE"		self addOptional: #PRESENTATION.	self addOptional: #PATHTYPE.	self addOptional: #WIDTH.	self addOptional: #STRANS.	self addOptional: #MAG.	self addOptional: #ANGLE.		self addRequired: #XY.	self addRequired: #STRING.		self addOptional: #PROPATTR.	self addOptional: #PROPVALUE.		self addRequired: #ENDEL.! !!GdsStreamLoopContext methodsFor: 'switch flow' stamp: 'kf 11/9/2009 19:12'!switchAREF: record	| handled |	#AREF = record type		ifTrue: [			^self upCount: #AREF].	handled := self switchElementBegin: record.	handled ifTrue: [^self].			handled := self switchSNAME: record.	handled ifTrue: [^self].			handled := self switchSTRANS: record.	handled ifTrue: [^self].		#COLROW = record type		ifTrue: [ | ints |			ints := record int2Array.			element columnCount: ints first.			element rowCount: ints second.			^self upCount: #COLROW].			handled := self switchElementEnd: record.	handled ifTrue: [^self].		! !!GdsStreamLoopContext methodsFor: 'switch flow' stamp: 'kf 10/24/2009 17:50'!switchBOUNDARY: record	| handled |	#BOUNDARY = record type		ifTrue: [			^self upCount: #BOUNDARY].	handled := self switchElementBegin: record.	handled ifTrue: [^self].			handled := self switchPrimitiveBegin: record.	handled ifTrue: [^self].	handled := self switchElementEnd: record.	handled ifTrue: [^self].! !!GdsStreamLoopContext methodsFor: 'switch flow' stamp: 'kf 10/24/2009 17:34'!switchPATH: record	| handled |	#PATH = record type		ifTrue: [			^self upCount: #PATH].	handled := self switchElementBegin: record.	handled ifTrue: [^self].			handled := self switchPrimitiveBegin: record.	handled ifTrue: [^self].			handled := self switchWireContext: record.	handled ifTrue: [^self].			handled := self switchElementEnd: record.	handled ifTrue: [^self].! !!GdsStreamLoopContext methodsFor: 'switch flow' stamp: 'kf 10/24/2009 17:33'!switchSREF: record	| handled |	#SREF = record type		ifTrue: [			^self upCount: #SREF].	handled := self switchElementBegin: record.	handled ifTrue: [^self].			handled := self switchSNAME: record.	handled ifTrue: [^self].			handled := self switchSTRANS: record.	handled ifTrue: [^self].			handled := self switchElementEnd: record.	handled ifTrue: [^self].		! !!GdsStreamLoopContext methodsFor: 'switch flow' stamp: 'kf 10/24/2009 17:34'!switchTEXT: record	| handled |	#TEXT = record type		ifTrue: [			^self upCount: #TEX].	handled := self switchPrimitiveBegin: record.	handled ifTrue: [^self].	#PRESENTATION = record type		ifTrue: ["FIXME"].			handled := self switchWireContext: record.	handled ifTrue: [^self].			handled := self switchSTRANS: record.	handled ifTrue: [^self].			handled := self switchXY: record.	handled ifTrue: [^self].			#STRING = record type		ifTrue: ["FIXME"].			handled := self switchElementEnd: record usingXY: false.	handled ifTrue: [^self].! !!GdsStreamLoopContext methodsFor: 'switch flow common' stamp: 'kf 10/24/2009 16:25'!switchElementBegin: record 	#ELFLAGS = record type		ifTrue: ["FIXME"].			#PLEX = record type		ifTrue: ["FIXME"].			^false			! !!GdsStreamLoopContext methodsFor: 'switch flow common' stamp: 'kf 10/24/2009 16:59'!switchElementEnd: record					^self switchElementEnd: record usingXY: true.! !!GdsStreamLoopContext methodsFor: 'switch flow common' stamp: 'kf 10/24/2009 16:58'!switchElementEnd: record usingXY: usingXY	| handled |	(usingXY and: [#XY = record type])				ifTrue: [			handled := self switchXY: record.						handled ifTrue: [^true]].	#PROPATTR = record type		ifTrue: ["FIXME"].			#PROPVALUE = record type		ifTrue: ["FIXME"].	#ENDEL = record type		ifTrue: [			self checkPreRequiredConsumed: record type.			self result: {false . element}.			self break: true.			self upCount: #ENDEL.			^true].	^false! !!GdsStreamLoopContext methodsFor: 'switch flow common' stamp: 'kf 10/27/2009 10:30'!switchPrimitiveBegin: record 	#LAYER = record type		ifTrue: [			element layerNumber: record int2.			self upCount: #LAYER.			^true].	"TODO: not have DATATYPE elements"		#DATATYPE = record type		ifTrue: [			element datatype: record int2.			self upCount: #DATATYPE.			^true].	^false			! !!GdsStreamLoopContext methodsFor: 'switch flow common' stamp: 'kf 10/24/2009 17:37'!switchSNAME: record	| structureName |	(self hasEntry: #SNAME) ifTrue: [^false].	#SNAME = record type		ifFalse: [^inform stderr: (inform missingField:  record type ofElement: element)].	structureName := record asString.	structureName isEmptyOrNil		ifTrue: [^inform abort: (inform missingField:  record type ofElement: element)].			element structureName: record asString.	self upCount: #SNAME.	^true! !!GdsStreamLoopContext methodsFor: 'switch flow common' stamp: 'kf 10/24/2009 16:13'!switchSTRANS: record	#STRANS = record type		ifTrue: [			self checkPreRequiredConsumed: record type.			element strans setReflected: record isReflected.			element strans setAngleAbsolute: record isAbsAngle.			element strans setMagAbsolute: record isAbsMag.			self upCount: #STRANS.			^true].					#MAG = record type		ifTrue: [			(self hasEntry: #STRANS)				ifFalse: ["TODO: MISSING REQUIRED ERROR HANDLE"].			element mag: record real8.			self upCount: #MAG.			^true].					#ANGLE = record type		ifTrue: [			(self hasEntry: #STRANS)				ifFalse: ["TODO: MISSING REQUIRED ERROR HANDLE"].			element angle: record real8.			self upCount: #ANGLE.			^true].	^false! !!GdsStreamLoopContext methodsFor: 'switch flow common' stamp: 'kf 10/24/2009 17:04'!switchWireContext: record 	#PATHTYPE = record type		ifTrue: [			element pathtype: record int2.			self upCount: #PATHTYPE.			^true].			#WIDTH = record type		ifTrue: [			element width: (record int4 * inform library userUnit).			self upCount: #WIDTH.			^true].			^false			! !!GdsStreamLoopContext methodsFor: 'switch flow common' stamp: 'kf 11/24/2009 13:12'!switchXY: record	#XY = record type				ifTrue: [ | points |			self checkPreRequiredConsumed: record type.			points := (record pointsScaledBy: inform library userUnit).			element vertices: points.			(element type == #aref or: [element type == #sref])				ifTrue: [element xy: points first].			(element type == #aref)				ifTrue: [ | col row mat |"AREF: Exactly 3 pairs                        1:  Array reference point                        2:  column_space*columns+reference_x                        3:  row_space*rows+reference_y"					element xy: points first.					mat := element transform.					col := mat invertPoint: points second.					"col x negative						ifTrue: [self error: 'error in AREF!! Found a y-axis mirrored array. This is impossible so I''m exiting'.].					col y abs > 1e-10						ifTrue: [self error: 'Error in AREF!! The second point in XY is broken']."						row := mat invertPoint: points third.					"row x abs > 1e-10						ifTrue: [self error: 'Error in AREF!! The third point in XY is broken'].	"					element xStep: (col x / element columnCount) asFloat.										element yStep: (row y / element rowCount) asFloat.					"row y negative 						ifTrue: [element yStep: element yStep negated]".].			self upCount: #XY.			^true].	^false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsStreamLoopContext class	instanceVariableNames: ''!Object subclass: #GdsStreamRecord	instanceVariableNames: 'bytes type dataBytes'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Developer-IO'!!GdsStreamRecord commentStamp: 'kf 10/23/2009 05:42' prior: 0!A GdsStreamRecord is xxxxxxxxx.Instance Variables	bytes:		<ByteArray>	dataBytes:		<ByteArray>	type:		<Symbol>bytes	- {recordKind, dataType, dataBytes}dataBytes	- pure data witout recordKind, dataTypetype	- #XY, #ANGLE, #MAG etc. !!GdsStreamRecord methodsFor: 'converter' stamp: 'kf 10/20/2009 22:19'!asString	^(self dataBytes  readStream upTo: 0) asString! !!GdsStreamRecord methodsFor: 'converter' stamp: 'kf 10/20/2009 22:41'!int2	^self int2Array first.	! !!GdsStreamRecord methodsFor: 'converter' stamp: 'kf 10/21/2009 09:59'!int2Array	| elSize numElements offset col |	elSize := 2.	numElements := self dataBytes size // elSize.	col := OrderedCollection new.	1 to: numElements do: [:index |		offset := ((index - 1) * elSize) + 1.		col add: (self dataBytes shortAt: offset bigEndian: true).].	 ^col asArray.	! !!GdsStreamRecord methodsFor: 'converter' stamp: 'kf 10/22/2009 17:53'!int4	^self int4Array first.	! !!GdsStreamRecord methodsFor: 'converter' stamp: 'kf 10/21/2009 10:00'!int4Array	| elSize numElements offset col |	elSize := 4.	numElements := self dataBytes size // elSize.	col := OrderedCollection new.	1 to: numElements do: [:index |		offset := ((index - 1) * elSize) + 1.		col add: (self dataBytes longAt: offset bigEndian: true).].	 ^col asArray.	! !!GdsStreamRecord methodsFor: 'converter' stamp: 'kf 10/22/2009 14:03'!real8	^self real8Array first! !!GdsStreamRecord methodsFor: 'converter' stamp: 'kf 10/21/2009 09:57'!real8Array	| elSize numElements col offset |	elSize := 8.	numElements := self dataBytes size // elSize.	col := OrderedCollection new.	1 to: numElements do: [:index |		offset := ((index - 1) * elSize) + 1.		col add: (self real8: (self dataBytes copyFrom: offset to: (offset + elSize - 1))).].	 ^col asArray.	! !!GdsStreamRecord methodsFor: 'accessing' stamp: 'kf 10/20/2009 14:49'!bytes: aByteArray	bytes := aByteArray.	! !!GdsStreamRecord methodsFor: 'accessing' stamp: 'kf 10/21/2009 15:06'!countBytes	^bytes size	! !!GdsStreamRecord methodsFor: 'accessing' stamp: 'kf 11/17/2009 20:22'!pointsScaledBy: aFacter	| items numPoints offsetX offsetY col |	items := self int4Array.	numPoints := items size / 2.	col := OrderedCollection new.	1 to: numPoints do: [:index |		offsetX := ((index - 1) * 2) + 1 .		offsetY := offsetX + 1.		col add: (			((items at: offsetX) * aFacter)@((items at: offsetY) * aFacter))].	^col asArray! !!GdsStreamRecord methodsFor: 'accessing' stamp: 'kf 10/20/2009 15:06'!type	type ifNil: [type := self lookupType].	^type.			! !!GdsStreamRecord methodsFor: 'private' stamp: 'kf 10/21/2009 09:50'!convertSelector	| dType |	dType := bytes at: 2.	dType = 1 ifTrue: [^#dataBytes].	dType = 2 ifTrue: [^#int2Array].	dType = 3 ifTrue: [^#int4Array].	dType = 5 ifTrue: [^#real8Array].	dType = 6 ifTrue: [^#asString].	^nil.	! !!GdsStreamRecord methodsFor: 'private' stamp: 'kf 10/20/2009 15:11'!dataBytes	dataBytes ifNil: [dataBytes := self lookupDataBytes ].	^dataBytes	! !!GdsStreamRecord methodsFor: 'private' stamp: 'kf 10/20/2009 15:10'!lookupDataBytes	^(bytes allButFirst: 2) asByteArray	! !!GdsStreamRecord methodsFor: 'private' stamp: 'kf 10/20/2009 15:06'!lookupType	^GdsStreamFormatReader typeForCode:  (bytes at: 1)		! !!GdsStreamRecord methodsFor: 'private' stamp: 'kf 10/21/2009 10:09'!readGdsReal: aByteArray 	| sign exponent mantissaInt mantissaFloatBitWidth mantissaFloat result |	self assert: [aByteArray size = 4 or: [aByteArray size = 8]].	sign := (aByteArray at: 1) bitAnd: 16r80.	exponent := ((aByteArray at: 1) bitAnd: 16r7F) - 64.  	mantissaInt := 0.	mantissaFloatBitWidth := (aByteArray size - 1) * 8.	2 to: aByteArray size do: [:i |		mantissaInt := mantissaInt << 8.		mantissaInt := mantissaInt + (aByteArray at: i)]. 	mantissaFloat := mantissaInt / (2 raisedTo: mantissaFloatBitWidth) asFloat.	result :=  mantissaFloat * (16 raisedTo: exponent).	sign = 1		ifTrue: [result := result negated].	^result"storage cost: 8byte(4word) 16bit machine8-byte real:SEEEEEEE MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM"	! !!GdsStreamRecord methodsFor: 'private' stamp: 'kf 10/21/2009 09:28'!real8: aByteArray	^self readGdsReal: aByteArray	! !!GdsStreamRecord methodsFor: 'printing' stamp: 'kf 10/21/2009 19:52'!dateAndTimes	^self dateAndTimes: self int2Array.! !!GdsStreamRecord methodsFor: 'printing' stamp: 'kf 10/21/2009 10:43'!dateAndTimes: aCollection	| fixYear |	self assert: [aCollection size = 12].	fixYear := [:yy | (yy between: 85 and: 99) ifTrue: [yy + (2000 - 100)] ifFalse: [yy + 2000]].	^{DateAndTime			year:  (fixYear value: (aCollection at: 1))			month:  (aCollection at: 2)			day:  (aCollection at: 3)			hour:  (aCollection at: 4)			minute:  (aCollection at: 5)			second: (aCollection at: 6).		DateAndTime			year: (fixYear value: (aCollection at: 7))			month:  (aCollection at: 8)			day:  (aCollection at: 9)			hour:  (aCollection at: 10)			minute:  (aCollection at: 11)			second: (aCollection at: 12).		}		! !!GdsStreamRecord methodsFor: 'printing' stamp: 'kf 10/20/2009 15:41'!printOn: aStream	aStream nextPutAll: self typeForPrint.	self hasData ifFalse: [^self].	aStream nextPut: $(.	self representOn: aStream.	aStream nextPut: $).	! !!GdsStreamRecord methodsFor: 'printing' stamp: 'kf 10/21/2009 10:38'!representData	| sel data |	sel := self convertSelector.	sel  ifNil: [^self dataBytes].			data := self perform: sel.	(data isKindOf: Collection)		ifTrue: [			data size = 1				ifTrue: [^data first].			(#(BGNLIB BGNSTR) includes: self type)				ifTrue: [^self dateAndTimes: data]].	^data.		! !!GdsStreamRecord methodsFor: 'printing' stamp: 'kf 10/21/2009 10:20'!representOn: aStream	aStream print: self representData.	! !!GdsStreamRecord methodsFor: 'printing' stamp: 'kf 10/20/2009 15:41'!typeForPrint	self isElementHeader ifTrue: [^self type].	^self type asLowercase.		! !!GdsStreamRecord methodsFor: 'testing' stamp: 'kf 10/20/2009 15:21'!hasData	^self dataBytes notEmpty	! !!GdsStreamRecord methodsFor: 'testing' stamp: 'kf 11/9/2009 23:13'!isAbsAngle	^self type = #STRANS and: [((self dataBytes at: 2) bitAnd: 16r01)  ~= 0]! !!GdsStreamRecord methodsFor: 'testing' stamp: 'kf 11/9/2009 23:13'!isAbsMag	^self type = #STRANS and: [((self dataBytes at: 2) bitAnd: 16r02) ~= 0]! !!GdsStreamRecord methodsFor: 'testing' stamp: 'kf 10/21/2009 16:14'!isElementHeader	^self class structureElementTypes includes: self type	! !!GdsStreamRecord methodsFor: 'testing' stamp: 'kf 11/9/2009 23:13'!isReflected	^self type = #STRANS and: [((self dataBytes at: 1) bitAnd: 16r80)  ~= 0]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsStreamRecord class	instanceVariableNames: ''!!GdsStreamRecord class methodsFor: 'as yet unclassified' stamp: 'kf 10/21/2009 16:12'!structureElementTypes	^#(BOUNDARY PATH TEXT BOX NODE SREF AREF)! !GdsStreamFormatReader initialize!