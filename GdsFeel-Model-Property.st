Model subclass: #GdsAShapeContext	instanceVariableNames: 'columnCount rowCount xStep yStep propertyOwner transforms'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Property'!!GdsAShapeContext commentStamp: 'kf 11/6/2009 13:48' prior: 0!A GdsArefContext is GDS II's ASHAPE value holder.Instance Variables!!GdsAShapeContext methodsFor: 'accessing' stamp: 'kf 11/9/2009 12:20'!asRequestString	^GdsFeel join:  (self values collect: [:each | each asString]) using: ' '.! !!GdsAShapeContext methodsFor: 'accessing' stamp: 'kf 11/5/2009 15:47'!columnCount	^columnCount! !!GdsAShapeContext methodsFor: 'accessing' stamp: 'kf 11/9/2009 14:14'!columnCount: anInteger	self assert: [anInteger isKindOf: Number].	self assert: [anInteger > 0] description: 'columnCount >= 1'.	columnCount = anInteger asInteger ifTrue: [^self].	columnCount := anInteger asInteger.	self refreshBounds.	self changed: #columnCount.	! !!GdsAShapeContext methodsFor: 'accessing' stamp: 'kf 11/6/2009 13:47'!propertyOwner: anObject	propertyOwner := anObject.	self addDependent: anObject.! !!GdsAShapeContext methodsFor: 'accessing' stamp: 'kf 11/5/2009 15:47'!rowCount	^rowCount! !!GdsAShapeContext methodsFor: 'accessing' stamp: 'kf 11/9/2009 14:15'!rowCount: anInteger	self assert: [anInteger isKindOf: Number].	self assert: [anInteger > 0] description: 'rowCount >= 1'.	rowCount = anInteger asInteger ifTrue: [^self].	rowCount := anInteger asInteger.	self refreshBounds.	self changed: #rowCount.	! !!GdsAShapeContext methodsFor: 'accessing' stamp: 'kf 11/9/2009 12:13'!values	^{self columnCount . self rowCount . self xStep .  self yStep }! !!GdsAShapeContext methodsFor: 'accessing' stamp: 'kf 11/9/2009 12:16'!values: anArray	self assert: [anArray size = 4].	self assert: [anArray allSatisfy: [:each | each isKindOf: Number]].	self columnCount: 	anArray first.	self rowCount: 	anArray second.	self xStep: anArray third.	self yStep: anArray fourth.	! !!GdsAShapeContext methodsFor: 'accessing' stamp: 'kf 11/5/2009 15:49'!xStep	^xStep! !!GdsAShapeContext methodsFor: 'accessing' stamp: 'kf 11/6/2009 16:03'!xStep: aFloat	self assert: [aFloat isKindOf: Number].	xStep = aFloat ifTrue: [^self].	xStep := aFloat.	self refreshBounds.	self changed: #xStep.	! !!GdsAShapeContext methodsFor: 'accessing' stamp: 'kf 11/5/2009 15:49'!yStep	^yStep! !!GdsAShapeContext methodsFor: 'accessing' stamp: 'kf 11/6/2009 16:03'!yStep: aFloat	self assert: [aFloat isKindOf: Number].	yStep = aFloat ifTrue: [^self].	yStep := aFloat.	self refreshBounds.	self changed: #yStep.	! !!GdsAShapeContext methodsFor: 'objects from disk' stamp: 'kf 11/9/2009 15:45'!asXmlElement	| elmt attrDict |	attrDict := Dictionary new.	self attributesOn: attrDict.	elmt := XMLElement named: 'ashape' attributes: attrDict.	^elmt.	! !!GdsAShapeContext methodsFor: 'objects from disk' stamp: 'kf 11/9/2009 15:49'!attributesFrom: aDictionary	self columnCount: (aDictionary at: 'cols' ifAbsent: [1]) asInteger. 	self rowCount: (aDictionary at: 'rows' ifAbsent: [1]) asInteger. 	self xStep: (aDictionary at: 'column-spacing' ifAbsent: [0.0]) asNumber. 	self yStep: (aDictionary at: 'row-spacing' ifAbsent: [0.0]) asNumber. 	! !!GdsAShapeContext methodsFor: 'objects from disk' stamp: 'kf 11/11/2009 09:36'!attributesOn: aDictionary	self columnCount >=2		ifTrue: [aDictionary at: 'cols' put: self columnCount asString].	self rowCount >=2		ifTrue: [aDictionary at: 'rows' put: self rowCount asString].	self xStep = 0.0		ifFalse: [				aDictionary at: 'column-spacing' put: self xStep asString].	self yStep = 0.0		ifFalse: [				aDictionary at: 'row-spacing' put: self yStep asString].! !!GdsAShapeContext methodsFor: 'objects from disk' stamp: 'kf 11/9/2009 15:51'!loadFromXmlNode: aXMLNode	self attributesFrom: aXMLNode attributes.! !!GdsAShapeContext methodsFor: 'updating' stamp: 'kf 11/12/2009 13:45'!changed: anObject	propertyOwner ifNil: [^super changed: anObject.].	propertyOwner changed: anObject.	super changed: anObject.! !!GdsAShapeContext methodsFor: 'updating' stamp: 'kf 12/9/2009 15:20'!refreshBounds	transforms := nil.	propertyOwner ifNil: [^self].	propertyOwner refreshBounds.! !!GdsAShapeContext methodsFor: 'initialization' stamp: 'kf 11/5/2009 15:49'!initialize	super initialize.	rowCount := 1.	columnCount := 1.	xStep := 0.0.	yStep := 0.0.		! !!GdsAShapeContext methodsFor: 'private' stamp: 'kf 11/5/2009 18:22'!lookupLocalBounds: localBounds	| vw vh |	vw := (self xStep * (self columnCount - 1)) + localBounds width. 	vh := (self yStep * (self rowCount - 1)) + localBounds height.	^localBounds origin extent: vw@vh ! !!GdsAShapeContext methodsFor: 'private' stamp: 'kf 12/9/2009 15:19'!lookupTransforms	| offset colTransforms |	colTransforms := OrderedCollection new.	1 to: self columnCount do: [:xIndex |		1 to: self rowCount do: [:yIndex |			offset :=  ((xIndex - 1) * self xStep)@((yIndex - 1) * self yStep).			colTransforms add: (MatrixTransform2x3 withOffset: offset).]].	 ^colTransforms asArray.! !!GdsAShapeContext methodsFor: 'private' stamp: 'kf 12/9/2009 15:19'!relativeTransforms	transforms ifNil: [transforms := self lookupTransforms].	^transforms! !Model subclass: #GdsKinds	instanceVariableNames: 'kinds keyOrder'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Property'!!GdsKinds methodsFor: 'as yet unclassified' stamp: 'kf 12/8/2009 13:49'!atKey: aKey	^kinds at: aKey ifAbsent: [nil]! !!GdsKinds methodsFor: 'as yet unclassified' stamp: 'kf 12/8/2009 21:34'!initialize	keyOrder := OrderedCollection new.	kinds := Dictionary new.	self specRecords 		do: [:triplet | | kind |			kind := GdsKind new initWithKey: (triplet first) description: (triplet second).			kind setVisible: triplet last.			kind setSelectable: true.			keyOrder add: triplet first.			kinds at: (triplet first)put: kind.]! !!GdsKinds methodsFor: 'as yet unclassified' stamp: 'kf 12/8/2009 14:32'!keys	^keyOrder asArray! !!GdsKinds methodsFor: 'as yet unclassified' stamp: 'kf 12/9/2009 15:43'!specRecords	^{	{'BD' .  'BOUNDARY' . true} . 	{'PC' .  'PATH CENTER' . true} . 	{'PB' .  'PATH BOUNDARY' . true} . 	{'TX' .  'TEXT' . true} .	{'TO' .  'TEXT ORIGIN' . false} .	"{'BX' .  'BOX'. false} ."	"{'ND' . 'NESTED DATA'. false} ."	"{'NO' . 'NODE'. false} ."	{'SO' .  'STRUCTURE ORIGIN' . false} .	{'SE' .  'STRUCTURE EXTENT' . false} .	{'AO' .  'ARRAY ORIGIN' . false} . 	{'AB' .  'ARRAY BORDER'. false} .	{'AE' .  'ARRAY EXTENT'. false}	"{'EX' . 'EXTERIOR DATA (STICKS)'. false}"	}! !Model subclass: #GdsLayers	instanceVariableNames: 'layers colorMapForLayer numbers'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Property'!!GdsLayers methodsFor: 'accessing' stamp: 'kf 11/17/2009 20:35'!atNumber: anInteger	| newLayer create result |	layers ifNil: [layers := Dictionary new.].	create := false.	result := layers 		at: anInteger 		ifAbsentPut: [			newLayer := GdsLayer fromLayerNumber: anInteger.			create := true.			newLayer].	create 		ifTrue: [			numbers := nil.			self changed: #newLayer with: newLayer.].	^result.! !!GdsLayers methodsFor: 'accessing' stamp: 'kf 11/17/2009 20:33'!lookupNumbers	layers ifNil: [^#()].	^layers keys asSortedArray.! !!GdsLayers methodsFor: 'accessing' stamp: 'kf 11/17/2009 20:34'!numbers	numbers ifNil: [numbers := self lookupNumbers].	^numbers.! !!GdsLayers methodsFor: 'initialization' stamp: 'kf 10/27/2009 15:26'!initialize	super initialize.! !!GdsLayers methodsFor: 'deprecated' stamp: 'kf 10/27/2009 15:26'!fillDefault	GdsCompatibility default layerNumberRange do: [:number |		self atNumber: number.].! !!GdsLayers methodsFor: 'objects from disk' stamp: 'kf 11/7/2009 22:47'!asXmlElement	| elmt |	elmt := XMLElement named: 'layers'.	self numbers do: [:num |		elmt addElement: (self atNumber: num) asXmlElement.].	^elmt! !!GdsLayers methodsFor: 'objects from disk' stamp: 'kf 11/8/2009 21:53'!loadFromXmlDocument: aXMLDocument	| topNode  layer layerNumber  |	topNode := aXMLDocument firstTagNamed: #layers.	topNode		elementsDo: [ :node |			layerNumber := (node attributes at: 'gdsno') asInteger.			layer := self atNumber: layerNumber.			layer loadFromXmlNode: node]! !Model subclass: #GdsState	instanceVariableNames: 'selectable visible'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Property'!!GdsState methodsFor: 'testing' stamp: 'kf 10/27/2009 15:53'!isSelectable	^selectable	! !!GdsState methodsFor: 'testing' stamp: 'kf 10/27/2009 15:53'!isVisible	^visible	! !!GdsState methodsFor: 'testing' stamp: 'kf 10/27/2009 15:12'!setSelectable: aBoolean	selectable :=  aBoolean.		! !!GdsState methodsFor: 'testing' stamp: 'kf 10/27/2009 15:12'!setVisible: aBoolean	visible := aBoolean.		! !!GdsState methodsFor: 'accessing' stamp: 'kf 5/11/2009 13:36'!stateLetter	(self isVisible and: [self isSelectable]) ifTrue: [^$@].	(self isVisible) ifTrue: [^$O].		(self isSelectable) ifTrue: [^$+].	^$-.			! !!GdsState methodsFor: 'objects from disk' stamp: 'kf 11/11/2009 09:41'!attributesFrom: aDictionary	self setSelectable: (aDictionary at: 'selectable' ifAbsent: ['true']) = 'true'.  	self setVisible: (aDictionary at: 'visible' ifAbsent: ['true']) = 'true'.  ! !!GdsState methodsFor: 'objects from disk' stamp: 'kf 11/11/2009 09:43'!attributesOn: aDictionary	self isSelectable		ifFalse: [			aDictionary at: 'selectable' put: self isSelectable asString].	self isVisible 		ifFalse: [				aDictionary at: 'visible' put: self isVisible asString].! !!GdsState methodsFor: 'as yet unclassified' stamp: 'kf 12/8/2009 13:47'!initialize	super initialize.	selectable := true.	visible := true.	! !GdsState subclass: #GdsKind	instanceVariableNames: 'key description'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Property'!!GdsKind methodsFor: 'as yet unclassified' stamp: 'kf 12/8/2009 13:46'!initWithKey: aKey description: aDescription	super initialize.	key := aKey.	description := aDescription.	! !!GdsKind methodsFor: 'as yet unclassified' stamp: 'kf 12/8/2009 14:18'!key	^key asString asUppercase.! !!GdsKind methodsFor: 'as yet unclassified' stamp: 'kf 12/8/2009 14:19'!keyString	^key asString asUppercase.! !!GdsKind methodsFor: 'as yet unclassified' stamp: 'kf 12/8/2009 16:14'!longDescription	^description! !!GdsKind methodsFor: 'as yet unclassified' stamp: 'kf 12/8/2009 14:19'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: self keyString.		aStream nextPut: $).	! !GdsState subclass: #GdsLayer	instanceVariableNames: 'no color colElements'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Property'!!GdsLayer methodsFor: 'accessing' stamp: 'kf 10/30/2009 14:48'!addElement: aGdsElement	colElements ifNil: [colElements := OrderedCollection new].	(colElements includes: aGdsElement)		ifFalse: [colElements add: aGdsElement].! !!GdsLayer methodsFor: 'accessing' stamp: 'kf 11/8/2009 21:35'!color	color ifNil: [color := Color white].	^color	! !!GdsLayer methodsFor: 'accessing' stamp: 'kf 10/29/2009 10:29'!color: aColor	color := aColor.	! !!GdsLayer methodsFor: 'accessing' stamp: 'kf 5/11/2009 13:23'!colorLetter	! !!GdsLayer methodsFor: 'accessing' stamp: 'kf 5/11/2009 13:21'!fill		! !!GdsLayer methodsFor: 'accessing' stamp: 'kf 5/11/2009 13:21'!fillLetter	^self fill name.! !!GdsLayer methodsFor: 'accessing' stamp: 'kf 10/27/2009 16:27'!layerNumber	^no.	! !!GdsLayer methodsFor: 'accessing' stamp: 'kf 5/10/2009 23:10'!number	^no.	! !!GdsLayer methodsFor: 'accessing' stamp: 'kf 5/11/2009 13:22'!style! !!GdsLayer methodsFor: 'accessing' stamp: 'kf 5/11/2009 13:23'!styleLetter	! !!GdsLayer methodsFor: 'printing' stamp: 'kf 5/10/2009 23:11'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: self number printString.	aStream nextPut: $).	! !!GdsLayer methodsFor: 'private' stamp: 'kf 5/10/2009 23:08'!setLayerNumber: aInteger.	no := aInteger.	! !!GdsLayer methodsFor: 'initialize-release' stamp: 'kf 10/27/2009 15:23'!initialize	super initialize.	self setSelectable: true.	self setVisible: true.	! !!GdsLayer methodsFor: 'objects from disk' stamp: 'kf 11/7/2009 22:39'!asXmlElement	| elmt attrDict colorElmt |	attrDict := Dictionary new.	self attributesOn: attrDict.	elmt := XMLElement named: 'layer' attributes: attrDict.	attrDict := Dictionary new.	GdsColorUtils rgbaAttributesOn: attrDict color: self color. 	colorElmt := XMLElement named: 'color' attributes: attrDict.	elmt addElement: colorElmt. 	^elmt.! !!GdsLayer methodsFor: 'objects from disk' stamp: 'kf 11/11/2009 09:41'!attributesFrom: aDictionary	super attributesFrom: aDictionary.	self setLayerNumber: (aDictionary at: 'gdsno') asInteger.	! !!GdsLayer methodsFor: 'objects from disk' stamp: 'kf 11/11/2009 09:42'!attributesOn: aDictionary	super attributesOn: aDictionary.	aDictionary at: 'gdsno' put: self layerNumber asString.	! !!GdsLayer methodsFor: 'objects from disk' stamp: 'kf 11/8/2009 22:22'!loadFromXmlNode: aXMLNode	self attributesFrom: aXMLNode attributes.	aXMLNode		elementsDo: [:colorNode |			self color: (GdsColorUtils  fromAttributes:  colorNode attributes)].			! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsLayer class	instanceVariableNames: ''!!GdsLayer class methodsFor: 'as yet unclassified' stamp: 'kf 5/10/2009 23:09'!fromLayerNumber: anInteger	^self new setLayerNumber: anInteger.! !Model subclass: #GdsStructureTransform	instanceVariableNames: 'offset mag angle reflected absAngle absMag matrix'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Property'!!GdsStructureTransform commentStamp: 'kf 5/11/2009 23:42' prior: 0!A GdsStructureTransform is transform information.Instance Variables!!GdsStructureTransform methodsFor: 'accessing' stamp: 'kf 5/12/2009 11:03'!angle	^angle.! !!GdsStructureTransform methodsFor: 'accessing' stamp: 'kf 12/2/2009 17:48'!angle: aDegrees	angle = aDegrees ifTrue: [^self].	angle := aDegrees.	matrix := nil.	! !!GdsStructureTransform methodsFor: 'accessing' stamp: 'kf 5/12/2009 11:03'!mag	^mag.! !!GdsStructureTransform methodsFor: 'accessing' stamp: 'kf 12/2/2009 17:50'!mag: aFactor	mag = aFactor ifTrue: [^self].	mag := aFactor.	matrix := nil.			! !!GdsStructureTransform methodsFor: 'accessing' stamp: 'kf 5/11/2009 23:50'!offset	^offset	! !!GdsStructureTransform methodsFor: 'accessing' stamp: 'kf 12/2/2009 17:50'!offset: aPoint	offset = aPoint ifTrue: [^self].	offset := aPoint.	matrix := nil.	! !!GdsStructureTransform methodsFor: 'convertor' stamp: 'kf 12/2/2009 17:47'!asMatrix2x3	matrix ifNil: [matrix := self lookupMatrix2x3].	^matrix.! !!GdsStructureTransform methodsFor: 'convertor' stamp: 'kf 12/2/2009 17:47'!lookupMatrix2x3	| t  rad radCos radSin|	t := MatrixTransform2x3 identity.	rad := angle degreesToRadians.	radCos :=  rad cos.	radSin := rad sin.	t a11: mag * radCos.	t a12: mag negated * radSin.	t a13: self offset x.	t a21: mag  * radSin.	t a22: mag * radCos.	t a23: self offset y.	reflected		ifTrue: [			t a12: t a12 negated.			t a22: t a22 negated].	 ^t! !!GdsStructureTransform methodsFor: 'copying' stamp: 'kf 5/15/2009 14:55'!copy	^super copy copyTransform.! !!GdsStructureTransform methodsFor: 'copying' stamp: 'kf 5/15/2009 14:55'!copyTransform	angle := angle deepCopy.	offset := offset deepCopy.	mag := mag deepCopy.! !!GdsStructureTransform methodsFor: 'initialize-release' stamp: 'kf 11/10/2009 14:17'!initialize	super initialize.	self safeReset.! !!GdsStructureTransform methodsFor: 'initialize-release' stamp: 'kf 11/10/2009 14:17'!safeReset	offset := 0.0@0.0.	mag := 1.0.	angle := 0.0.		absAngle := false.	absMag := false.	reflected := false.! !!GdsStructureTransform methodsFor: 'testing' stamp: 'kf 10/23/2009 21:31'!isAbsAngle	^absAngle! !!GdsStructureTransform methodsFor: 'testing' stamp: 'kf 10/23/2009 21:31'!isAbsMag	^absMag! !!GdsStructureTransform methodsFor: 'testing' stamp: 'kf 11/10/2009 00:06'!isReflected	^reflected .! !!GdsStructureTransform methodsFor: 'testing' stamp: 'kf 12/2/2009 17:49'!setAngleAbsolute: aBoolean	absAngle := aBoolean.	matrix := nil.		! !!GdsStructureTransform methodsFor: 'testing' stamp: 'kf 12/2/2009 17:49'!setMagAbsolute: aBoolean	absMag := aBoolean.	matrix := nil.		! !!GdsStructureTransform methodsFor: 'testing' stamp: 'kf 12/2/2009 17:50'!setReflected: aBoolean	reflected = aBoolean ifTrue: [^self].	reflected := aBoolean.	matrix := nil.		! !!GdsStructureTransform methodsFor: 'printing' stamp: 'kf 11/10/2009 16:54'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self mag = 1.0		ifFalse: [			aStream print: self mag].	self angle = 0.0		ifFalse: [			aStream print: self angle.			aStream nextPut: $,].	self isReflected		ifTrue: [			aStream nextPutAll: 'REFL'].	aStream nextPut: $).	! !Model subclass: #GdsWireContext	instanceVariableNames: 'width outlineSegMap boundaryPoints pathtype element'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Property'!!GdsWireContext commentStamp: 'kf 11/12/2008 12:05' prior: 0!A GdsWireContext is GDS II's PATH or TEXT shared property.Instance Variables	boundaryPoints:		<Array<Point>>	outlineSegMap:		<Object>	width:		<Float>boundaryPoints	- xxxxxoutlineSegMap	- xxxxxwidth	- xxxxx!!GdsWireContext methodsFor: 'accessing' stamp: 'kf 10/24/2008 22:10'!boundaryPoints	boundaryPoints ifNil: [boundaryPoints := self lookupBoundaryPoints].	^boundaryPoints! !!GdsWireContext methodsFor: 'accessing' stamp: 'kf 10/26/2008 12:04'!dataOutlinePoints	^ self boundaryPoints! !!GdsWireContext methodsFor: 'accessing' stamp: 'kf 10/24/2009 20:41'!element: aGdsElement	element := aGdsElement.! !!GdsWireContext methodsFor: 'accessing' stamp: 'kf 10/17/2008 22:30'!halfWidth	^self width / 2.0.! !!GdsWireContext methodsFor: 'accessing' stamp: 'kf 10/21/2009 17:17'!pathtype	^pathtype! !!GdsWireContext methodsFor: 'accessing' stamp: 'kf 10/27/2009 13:47'!pathtype: aInteger	self assert: [aInteger isKindOf: Integer].	pathtype = aInteger ifTrue: [^self].	pathtype := aInteger.	self removeGeometryCache.	self changed: #pathtype.! !!GdsWireContext methodsFor: 'accessing' stamp: 'kf 10/24/2009 20:44'!vertices	^element vertices! !!GdsWireContext methodsFor: 'accessing' stamp: 'kf 10/17/2008 17:17'!width	width ifNil: [width := 10.0].	^width.! !!GdsWireContext methodsFor: 'accessing' stamp: 'kf 12/8/2009 13:22'!width: aFloat	width = aFloat ifTrue: [^self].	width := aFloat.	self removeGeometryCache.	self changed: #width.	! !!GdsWireContext methodsFor: 'outline' stamp: 'kf 10/24/2009 21:01'!degressOfPathType	^self pathtype = 0 ifTrue: [90] ifFalse: [45].! !!GdsWireContext methodsFor: 'outline' stamp: 'kf 10/24/2009 20:52'!lookupBoundaryPoints	|  unit r offsetRadians getSegsBlock lastSeg vpLeftPrev vpLeft vpRight vpRightPrev count points colPoints colLeftPoints colRightPoints segOutlinePoints segs1 segs2 leftSeg1 leftSeg2 rightSeg1 rightSeg2 |	colPoints := OrderedCollection new.		colLeftPoints := OrderedCollection new.		colRightPoints := OrderedCollection new.		points := self vertices.	offsetRadians :=  self degressOfPathType degreesToRadians.	unit := offsetRadians sin.	r := unit = 0 ifTrue: [self halfWidth] ifFalse: [self halfWidth / unit].	lastSeg := nil.	vpLeft := nil.	vpLeftPrev := nil.	vpRight := nil.	vpRightPrev := nil.	count := 0.	getSegsBlock := [:each | self outlineSegmentsOf: each offsetRadians: offsetRadians r: r].	self lineSegmentsDo: [:seg |		|  |		count := count + 1.		segOutlinePoints := seg outlinePoints: offsetRadians r: r.		(points size = 2)			ifTrue: [				colPoints addAll: {segOutlinePoints at: 3 . segOutlinePoints at: 2 . segOutlinePoints at: 1 . segOutlinePoints at: 4 . segOutlinePoints at: 3}.				^colPoints asArray].			segs1 := getSegsBlock value: seg.		leftSeg1 := segs1 second reversed.		rightSeg1 := segs1 fourth .		(count == 1)			ifTrue: [				vpLeft := leftSeg1 start clone..				vpRight := rightSeg1 start clone..				vpLeftPrev := leftSeg1 start clone..				vpRightPrev := rightSeg1 start clone..								].				lastSeg ifNotNil: [			segs2 := getSegsBlock value: lastSeg.			leftSeg2 := segs2 second reversed.			rightSeg2 := segs2 fourth .			vpLeft := leftSeg1 intersectionWith: leftSeg2  virtualAllowed: true.			vpLeft ifNil: [vpLeft := leftSeg2 end clone.].			vpLeftPrev 				ifNil:[vpLeftPrev := leftSeg2 start].			colLeftPoints add: vpLeftPrev.			colLeftPoints add: vpLeft.			vpLeftPrev := vpLeft clone.						vpRight := rightSeg1 intersectionWith: rightSeg2  virtualAllowed: true.			vpRight ifNil: [vpRight := rightSeg2 end clone.].			colRightPoints add: vpRightPrev.			colRightPoints add: vpRight.			vpRightPrev := vpRight clone.		count = (points size - 1)			ifTrue: [				vpLeft ifNotNil: [					colLeftPoints add: leftSeg1 end copy].				vpRight ifNotNil: [					colRightPoints add: rightSeg1 end copy]].].		lastSeg := seg].	colPoints addAll: colLeftPoints.	colPoints addAll: colRightPoints reversed.		colPoints size >= 2 			ifTrue: [colPoints add: colPoints first].	self assert: [colPoints size >= 5].	^colPoints asArray.	! !!GdsWireContext methodsFor: 'outline' stamp: 'kf 10/24/2009 20:52'!offsetRadiansAndRadiusDo: aBlock	|  unit r offsetRadians  |	offsetRadians :=  self degressOfPathType degreesToRadians.	unit := offsetRadians sin.	r := unit = 0 ifTrue: [self halfWidth] ifFalse: [self halfWidth / unit].	aBlock value: offsetRadians value: r.! !!GdsWireContext methodsFor: 'outline' stamp: 'kf 6/8/2009 17:19'!outlinePointsOf: aLineSegment	| points |	points := #() copy.	self offsetRadiansAndRadiusDo: [:radians :r |		points := aLineSegment outlinePoints: radians r: r.].	^points! !!GdsWireContext methodsFor: 'outline' stamp: 'kf 10/17/2008 22:09'!outlineSegmentsOf: aLineSegment	outlineSegMap ifNil: [outlineSegMap := Dictionary new].	! !!GdsWireContext methodsFor: 'outline' stamp: 'kf 10/17/2008 22:12'!outlineSegmentsOf: aLineSegment offsetRadians: radians r: r	outlineSegMap ifNil: [outlineSegMap := Dictionary new].	^outlineSegMap 		at: aLineSegment 		ifAbsentPut: [aLineSegment outlineSegments: radians r: r].	! !!GdsWireContext methodsFor: 'initialization' stamp: 'kf 10/24/2009 20:14'!initialize	super initialize.	width := 0.0.	pathtype := 0.! !!GdsWireContext methodsFor: 'other' stamp: 'kf 10/24/2009 20:55'!lineSegmentsDo: aLineSegmentBlock	element lineSegmentsDo: aLineSegmentBlock! !!GdsWireContext methodsFor: 'other' stamp: 'kf 10/27/2009 12:06'!removeGeometryCache	boundaryPoints := nil.	outlineSegMap := nil.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsWireContext class	instanceVariableNames: ''!!GdsWireContext class methodsFor: 'testing' stamp: 'kf 5/4/2009 11:15'!hasWidth	^true.! !!GdsWireContext class methodsFor: 'accessing' stamp: 'kf 9/20/2008 14:18'!requiredVertexCount	^2.! !!GdsWireContext class methodsFor: 'accessing' stamp: 'kf 10/23/2008 19:53'!type	^#path! !