Object subclass: #GdsObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Kernel'!!GdsObject methodsFor: 'as yet unclassified' stamp: 'kf 5/27/2009 16:00'!error: aString	^self class error: aString! !!GdsObject methodsFor: 'as yet unclassified' stamp: 'kf 5/27/2009 16:11'!runtimeError: aString	^self class runtimeError: aString.! !!GdsObject methodsFor: 'as yet unclassified' stamp: 'kf 5/27/2009 16:00'!syntaxError: aString	^self class syntaxError: aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsObject class	instanceVariableNames: ''!!GdsObject class methodsFor: 'error handling' stamp: 'kf 5/27/2009 15:59'!error: aString	^GdsError new signal:  aString! !!GdsObject class methodsFor: 'error handling' stamp: 'kf 5/27/2009 16:10'!runtimeError: aString	^GplRuntimeError new signal:  aString! !!GdsObject class methodsFor: 'error handling' stamp: 'kf 5/27/2009 15:54'!syntaxError: aString	^GplSyntaxError new signal:  aString! !GdsObject subclass: #GplParserBase	instanceVariableNames: 'input words'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Kernel'!!GplParserBase commentStamp: 'kf 4/19/2009 21:28' prior: 0!A GplParser is GPL Parser.- scanToken: aString phase1 parsing. no type tag spliter. all element class is String. but lineEnding only #cr (Symbol)TODO: build parse tree.Instance Variables	colWords:		<Collection<String|Symbol>>	currentWords:		<Collection<String|Symbol>>	input:		<ReadStream>	stack:		<Collection<Collection>>colWords	- xxxxxcurrentWords	- current level word collectioninput	- GPL II statement input stream.stack	- using pushLevel: popLevel: !!GplParserBase methodsFor: 'accessing' stamp: 'kf 11/11/2008 10:00'!char2Words	^{ ':=' . '<>' . '<=' . '>=' }! !!GplParserBase methodsFor: 'accessing' stamp: 'kf 5/2/2009 17:13'!scanToken	| c c2 start |	input atEnd ifTrue: [^self].		c := input peek.	c ifNil: [^self].	(self class isTabOrSpace: c) ifTrue: [^self handleBlanks.].	(self class isNameFirst: c) ifTrue: [^self scanWord].	(self class isNumberFirst: c) ifTrue: [^self scanNumber].	c = $" ifTrue: [^self scanString].	c = $| ifTrue: [^self scanInlineComment].	c = $` ifTrue: [^self scanRangeComment.].	c = $^ ifTrue: [2 timesRepeat: [c := input next].^self].	"c := input next."	start := input position + 1.	self char2Words		do: [:each |			(c = each first) 				ifTrue: [					c2 := self peek2.					(c2 = each second)						ifTrue: [ 							input skip: 2.												^self pushNotEmpty: (each readStream) start: start]]].	('()[]:;' includes: c)		ifTrue: [			input skip: 1.			^self pushNotEmpty: (c asString readStream) start: start].	c isSpecial ifTrue: [		input skip: 1.		^self pushNotEmpty: (c asString readStream) start: start].	(self class isLineEndFirst: c)		ifTrue: [			^self scanLineEnd: c].	self error: 'USE ILLIGAL CHARACTER: ', (c asString printString) .! !!GplParserBase methodsFor: 'private' stamp: 'kf 4/20/2009 15:36'!handleBlanks	self skipBlanks.				! !!GplParserBase methodsFor: 'private' stamp: 'kf 4/27/2009 10:29'!peek2	| nextObject |	nextObject := nil.	2 timesRepeat: [		input atEnd ifTrue: [^nil].		nextObject := input next].	input position: input position - 2.	^nextObject! !!GplParserBase methodsFor: 'private' stamp: 'kf 4/20/2009 10:56'!pushNotEmpty: aWriteStream	self pushNotEmpty: aWriteStream start: -1. "ignore -1"		! !!GplParserBase methodsFor: 'private' stamp: 'kf 4/20/2009 10:56'!pushNotEmpty: aWriteStream start: aInteger	aWriteStream contents ifNotEmpty: [self pushWord: aWriteStream contents].		! !!GplParserBase methodsFor: 'private' stamp: 'kf 4/19/2009 21:30'!pushWord: aWord	words add: aWord.			! !!GplParserBase methodsFor: 'private' stamp: 'kf 4/25/2009 20:46'!scanBlanks	| noSpace start s |	start := input position + 1.	input atEnd ifTrue: [^self].	noSpace := false.	s := self writeStream.	[input atEnd or: [noSpace]]		whileFalse: [			| c |			c := input next.			noSpace := (self class isTabOrSpace:  c ) not.			noSpace ifFalse: [s nextPut: c].].	input atEnd		ifTrue: [noSpace ifTrue: [input skip: -1]]		ifFalse: [input skip: -1].	self pushNotEmpty: s start: start.					! !!GplParserBase methodsFor: 'private' stamp: 'kf 4/26/2009 21:29'!skipBlanks	| noSpace |	input atEnd ifTrue: [^self].	noSpace := false.	[input atEnd or: [noSpace]]		whileFalse: [			| c |			c := input next.			noSpace := (self class isTabOrSpace:  c ) not.].	input atEnd		ifTrue: [noSpace ifTrue: [input skip: -1]]		ifFalse: [input skip: -1].						! !!GplParserBase methodsFor: 'private' stamp: 'kf 11/11/2008 08:13'!writeStream	^WriteStream on: (String new: 1000).	! !!GplParserBase methodsFor: 'initialize-release' stamp: 'kf 4/20/2009 10:27'!initialize	super initialize.	words := OrderedCollection new.! !!GplParserBase methodsFor: 'scanning-deprecated' stamp: 'kf 4/20/2009 13:55'!scanDigitOnly	| digit s start |	digit := true.	s := self writeStream.	start := input position + 1.	[input atEnd not and: [digit]]		whileTrue: [			| c |			c := input next.			digit := c isDigit.			digit ifTrue: [s nextPut: c]].	self pushNotEmpty: s start: start.		! !!GplParserBase methodsFor: 'scanning' stamp: 'kf 4/26/2009 15:09'!scanInlineComment	| c endOfLine s start |	endOfLine := false.	s := self writeStream.	start := input position + 1.	[input atEnd or: [endOfLine]]		whileFalse: [			c := input next.			(self class isLineEndFirst: c)				ifTrue: [					endOfLine := true.					input skip: -1.]				ifFalse: [s nextPut: c].].	self pushNotEmpty: s start: start.	! !!GplParserBase methodsFor: 'scanning' stamp: 'kf 4/26/2009 14:00'!scanLineEnd: aCharacter	| length |	length := 0.	(aCharacter = Character cr)		ifTrue: [			self pushWord: #cr.			length := length + 1.			(self peek2 = Character lf)				ifTrue: [					length := length + 1].			input skip: length.			^self].	(aCharacter = Character lf)		ifTrue: [			length := length + 1.			input skip: length.									^self pushWord: #cr.].! !!GplParserBase methodsFor: 'scanning' stamp: 'kf 4/20/2009 13:14'!scanNoSpace	| space s start |	space := false.	s := self writeStream.	start := input position + 1.	[input atEnd  or: [space]]		whileFalse: [			| c |			c := input next.			space := self isTabOrSpace: c.			space ifFalse: [space := '()' includes: c].			space ifFalse: [s nextPut: c]].	self pushNotEmpty: s start: start.		! !!GplParserBase methodsFor: 'scanning' stamp: 'kf 4/25/2009 20:46'!scanNumber	"TODO: implements floating point expression. ex. 1E-5"	| accept s start exponensialCount minusCount |	accept := true.	s := self writeStream.	start := input position + 1.	exponensialCount := 0.	minusCount := 0.		[input atEnd not and: [accept]]		whileTrue: [			| c |			c := input next.			(c = $E)				ifTrue: [					(exponensialCount >= 1) ifTrue: [self error: 'Illigal Number format'].										exponensialCount := exponensialCount + 1].			(c = $-)				ifTrue: [.					s contents 						ifNotEmpty: [							(s contents last isDigit)								ifTrue:[accept := false]].										minusCount := minusCount + 1].			accept ifTrue: [				accept := self class isNumberAllowed: c.				accept ifTrue: [s nextPut: c]]].			input atEnd		ifTrue: [accept ifFalse: [input skip: -1]]		ifFalse: [input skip: -1].	self pushNotEmpty: s start: start.	! !!GplParserBase methodsFor: 'scanning' stamp: 'kf 4/20/2009 14:43'!scanRangeComment	| c endOfComment s start |	endOfComment := false.	s := self writeStream.	start := input position + 1.	[input atEnd or: [endOfComment]]		whileFalse: [			c := input next.			(c = $')				ifTrue: [endOfComment := true].			s nextPut: c.].	self pushNotEmpty: s start: start.	! !!GplParserBase methodsFor: 'scanning' stamp: 'kf 5/21/2009 18:31'!scanString	| count s end start |	count := 0.	end := false.	s := self writeStream.	start := input position + 1.	[input atEnd  or: [end ]]		whileFalse: [			| c |			c := input next.			c = $" ifTrue: [count := count + 1].			c = $" ifFalse:[ end := count \\ 2 = 0].			end ifFalse: [s nextPut: c]].	input atEnd		ifTrue: [end ifTrue: [input skip: -1]]		 ifFalse: [input skip: -1].		(s contents  = '"')		ifTrue: [^self error: 'MISSING ". STRING NOT TERMINATED.'].	(s contents last = $")		ifFalse: [^self error: 'MISSING ". STRING NOT TERMINATED.'].	self pushNotEmpty: s start: start.		! !!GplParserBase methodsFor: 'scanning' stamp: 'kf 4/25/2009 21:01'!scanWord	| accept s  start |	start := input position.	accept := true.	s := self writeStream.	start := input position + 1.	[input atEnd not and: [accept]]		whileTrue: [			| c |			c := input next.			accept := self class isNameAfterSecond: c .			accept ifTrue: [s nextPut: c]].			s contents size > 32 ifTrue: [self error: 'VARIABLE NAME LIMIT 32'].	input atEnd		ifTrue: [accept ifFalse: [input skip: -1]]		 ifFalse: [input skip: -1].	self pushNotEmpty: s start: start.	! !!GplParserBase methodsFor: 'parse' stamp: 'kf 5/2/2009 17:14'!splitTokens: aString 	self splitTokensFrom: aString readStream.	^ words asArray! !!GplParserBase methodsFor: 'private-scanning' stamp: 'kf 4/20/2009 17:36'!splitTokensFrom: aStream 	| count infinit lastPos |	input := aStream.	infinit := false.	count := 0.	lastPos := 0.	[input atEnd or: [infinit]] 		whileFalse: [ 			self scanToken.			(lastPos = input position)				ifTrue: [					count := count + 1.					count > 1000 ifTrue: [infinit := true]].			infinit ifTrue: [				Transcript cr; show: '*** WARNING *** infinit loop in parser'.			lastPos := input position]].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplParserBase class	instanceVariableNames: ''!!GplParserBase class methodsFor: 'testing' stamp: 'kf 4/25/2009 20:44'!isLineEndFirst: aCharacter	^(aCharacter = Character cr) or: [aCharacter = Character lf]! !!GplParserBase class methodsFor: 'testing' stamp: 'kf 4/25/2009 20:44'!isNameAfterSecond: aCharacter	(aCharacter isLetter or: [aCharacter isDigit]) ifTrue: [^true].	^'$_' includes: aCharacter						! !!GplParserBase class methodsFor: 'testing' stamp: 'kf 4/25/2009 20:44'!isNameFirst: aCharacter	aCharacter = $$ ifTrue: [^true].	^aCharacter isLetter						! !!GplParserBase class methodsFor: 'testing' stamp: 'kf 4/25/2009 20:44'!isNumberAllowed: aCharacter	^aCharacter isDigit or:['-.E' includes: aCharacter]						! !!GplParserBase class methodsFor: 'testing' stamp: 'kf 4/25/2009 20:44'!isNumberFirst: aCharacter	^aCharacter isDigit or:['-.' includes: aCharacter]						! !!GplParserBase class methodsFor: 'testing' stamp: 'kf 4/25/2009 20:44'!isTabOrSpace: aCharacter	^aCharacter asciiValue == 32 or: [aCharacter asciiValue == 9]						! !!GplParserBase class methodsFor: 'parse' stamp: 'kf 11/11/2008 14:06'!splitTokens: aString	^self new splitTokens: aString.! !!GplParserBase class methodsFor: 'parse' stamp: 'kf 4/19/2009 20:55'!textTookenStream: aString	^ReadStream on: (self splitTokens: aString).! !!GplParserBase class methodsFor: 'parse' stamp: 'kf 4/19/2009 20:52'!tokenStream: aString	^ReadStream on: (self splitTokens: aString).! !GplParserBase subclass: #GplParser	instanceVariableNames: 'source ranges'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Kernel'!!GplParser commentStamp: 'kf 4/22/2009 21:59' prior: 0!A GplParser is GPL Parser.- scanToken: aString phase1 parsing. no type tag spliter. all element class is String. but lineEnding only #cr (Symbol)TODO: build parse tree.Instance Variables	colWords:		<Collection<String|Symbol>>	currentWords:		<Collection<String|Symbol>>	input:		<ReadStream>	stack:		<Collection<Collection>>colWords	- xxxxxcurrentWords	- current level word collectioninput	- GPL II statement input stream.stack	- using pushLevel: popLevel: !!GplParser methodsFor: 'private' stamp: 'kf 4/24/2009 11:45'!assertGplTokens: aCollection	self class assertGplTokens: aCollection	! !!GplParser methodsFor: 'private' stamp: 'kf 4/20/2009 15:37'!handleBlanks	self scanBlanks.! !!GplParser methodsFor: 'private' stamp: 'kf 4/20/2009 10:54'!pushNotEmpty: aWriteStream start: aInteger	aWriteStream contents ifEmpty: [^self].	self start: aInteger length: aWriteStream contents size.		! !!GplParser methodsFor: 'private' stamp: 'kf 4/20/2009 15:51'!splitRanges	super splitTokens: source.	! !!GplParser methodsFor: 'private' stamp: 'kf 4/22/2009 18:34'!splitTokens: aString withSpace: aBoolean	| result |	self source: aString.	self splitRanges.	result := self tokens collect: [:r | r fragment].	aBoolean ifFalse: [		result := (self tokens reject: [:r | r type = #space]) collect: [:r | r fragment]].	^result.! !!GplParser methodsFor: 'accessing' stamp: 'kf 4/22/2009 17:30'!decodeSource	| prevRange |	^self tokens do: [:r |		self fragmentOfRange: r.		prevRange := r.]! !!GplParser methodsFor: 'accessing' stamp: 'kf 4/20/2009 15:58'!fragmentOfRange: aGplRange	| s |	s := self source copyFrom: aGplRange start to: aGplRange end.	(s anySatisfy: [:each | {Character cr . Character lf} includes: each])	ifTrue: [^#cr].		^s.! !!GplParser methodsFor: 'accessing' stamp: 'kf 4/20/2009 10:29'!source	^source! !!GplParser methodsFor: 'accessing' stamp: 'kf 4/20/2009 10:28'!source: aString	source := aString! !!GplParser methodsFor: 'accessing' stamp: 'kf 4/22/2009 17:30'!splitedWords	^self tokens collect: [:r | r fragment]! !!GplParser methodsFor: 'accessing' stamp: 'kf 4/22/2009 18:35'!tokens	^self tokensIgnoreSpace: true.! !!GplParser methodsFor: 'accessing' stamp: 'kf 4/22/2009 18:36'!tokensIgnoreSpace: aBoolean	aBoolean		ifTrue: [			^(ranges reject: [:r | r fragment trimBlanks isEmpty]) asArray].	^ranges asArray! !!GplParser methodsFor: 'initialization' stamp: 'kf 4/20/2009 13:03'!initialize	super initialize.	ranges := OrderedCollection new.	! !!GplParser methodsFor: 'range recording' stamp: 'kf 4/22/2009 17:26'!rangeType: aSymbol start: s end: e 	^ranges add: (GplToken start: s end: e type: aSymbol parser: self)! !!GplParser methodsFor: 'range recording' stamp: 'kf 4/22/2009 18:39'!start: s end: e 	^self rangeType: #unresolved start: s end: e.	! !!GplParser methodsFor: 'range recording' stamp: 'kf 4/20/2009 13:23'!start: s length: l 	^self start: s end: s + l - 1.	! !!GplParser methodsFor: 'scanning' stamp: 'kf 4/26/2009 19:22'!scanLineEnd: aCharacter	| start length |	start := input position + 1.	length := 0.	(aCharacter = Character cr)		ifTrue: [			length := 1.			self pushWord: #cr.			(input peek = Character lf)				ifTrue: [					length := length + 1].			input skip: length.			self rangeType: #cr start: start end: start + length - 1.			^self].	(aCharacter = Character lf)		ifTrue: [			length := 1.			input skip: 1.			self rangeType: #cr start: start end: start + length - 1.			^self pushWord: #cr.].	! !!GplParser methodsFor: 'parse' stamp: 'kf 4/22/2009 17:34'!splitTokens: aString	^self splitTokens: aString withSpace: false.! !!GplParser methodsFor: 'analysis' stamp: 'kf 4/24/2009 15:19'!vectorAnalysisFromTokens: aGplTokens	| stream vectorTokens token newOutput|	self assertGplTokens: aGplTokens.	stream := ReadStream on: aGplTokens.	newOutput := OrderedCollection new.	vectorTokens := OrderedCollection new.	[stream atEnd] 		whileFalse: [			token := stream next.			token type = #number 				ifTrue: [.					vectorTokens add: token]				ifFalse: [					vectorTokens						ifNotEmpty: [							| newToken |							newToken := GplToken newFromTokens: vectorTokens.							newOutput add: newToken.							vectorTokens := OrderedCollection new.].					newOutput add: token]].		vectorTokens			ifNotEmpty: [				| newToken |				newToken := GplToken newFromTokens: vectorTokens.				newOutput add: newToken.				vectorTokens := OrderedCollection new.].	^newOutput asArray.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplParser class	instanceVariableNames: ''!!GplParser class methodsFor: 'private' stamp: 'kf 4/24/2009 11:45'!assertGplTokens: aCollection	self assert: [aCollection allSatisfy: [:each | each isMemberOf: GplToken]].	! !!GplParser class methodsFor: 'testing' stamp: 'kf 5/23/2009 11:58'!isNumberFragment: aString		^(GdsDglType bestClassOfStatement: aString) isNil not.! !!GplParser class methodsFor: 'testing' stamp: 'kf 9/8/2012 16:58'!isOperatorFragment: aString		self operatorSpec do: [:specRecord |		(specRecord value includes: aString asUppercase)			ifTrue: [^true]].	aString size = 1		ifTrue: [			^'+-*%;,[]' includes: aString first].		^false.! !!GplParser class methodsFor: 'specification' stamp: 'kf 4/27/2009 17:51'!operatorSpec	^{	377 -> #('[]').	20 -> #('ABS' 'ARCTAN' 'CEILING' 'COS' 'FLOOR' 'GRADEDOWN' 'GRADEUP'	        'LN' 'NOT' 'PI' 'SIN' 'SORT' 'SORTDOWN' 'TAN' 	        '+ (monadic)' '- (monadic)' '* (monadic)' '% (monadic)').	17 -> #('LOGBASE' 'POWER').	16 -> #('MAX' 'MIN' 'MOD' '* (dyadic)' '% (dyadic)').	15 -> #('+ (dyadic)' '- (dyadic)').	13 -> #('EQ' 'GEQ' 'GT' 'IN' 'LEQ' 'NEQ'	        '=' '<' '>' '<=' '>=' '<>').	12 -> #('OR' 'XOR' 'NOR').	11 -> #('AND' 'NAND').	10 -> #('IOTA' 'SHAPE' 'LENGTH' 'SIZE' 'TYPEOF'		      'RANK' ', (monadic)').	7 -> #('INDEXOF' 'RESHAPE').	6 -> #(', (dyadic)').	5 -> #(';').	0 -> #(':=')	}! !!GplParser class methodsFor: 'evaluter' stamp: 'kf 4/22/2009 18:21'!tokensFrom: aString	| parser |	parser := self new source: aString.	parser splitRanges.	^parser tokens.! !GdsObject subclass: #GplToken	instanceVariableNames: 'start end type parser subtokens argumentType'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Kernel'!!GplToken methodsFor: 'testing' stamp: 'kf 5/29/2009 21:22'!= aGplToken	^(self start = aGplToken start)	and: [self end = aGplToken end]	and: [self parser source = aGplToken parser  source]	! !!GplToken methodsFor: 'testing' stamp: 'kf 6/8/2009 17:07'!hasSubTokens	subtokens ifNil: [^false].	^subtokens isEmpty not.! !!GplToken methodsFor: 'testing' stamp: 'kf 5/26/2009 17:09'!isArithmeticOperator	^ self fragment size = 1 and: ['+-*%' includes: self fragment first]! !!GplToken methodsFor: 'testing' stamp: 'kf 9/8/2012 16:03'!isBuiltinDyadic	^(self type = #operator or: [self type = #builtinMethod])		and: [			self class implementedDyadicMethods 				includes: (self fragment asUppercase )]! !!GplToken methodsFor: 'testing' stamp: 'kf 9/8/2012 16:05'!isBuiltinMonadic	^(self type = #operator or: [self type = #builtinMethod])		and: [			self class implementedMonadicMethods 				includes: (self fragment asUppercase)]! !!GplToken methodsFor: 'testing' stamp: 'kf 4/23/2009 17:14'!isComment	^self type = #comment.! !!GplToken methodsFor: 'testing' stamp: 'kf 5/30/2009 10:09'!isFunctionCall	^self isProcedureCall not! !!GplToken methodsFor: 'testing' stamp: 'kf 9/9/2012 08:38'!isInspectMonadic	^(self type = #operator or: [self type = #builtinMethod])		and: [			(self class inspectMonadicMethods				includes: (self fragment asUppercase))]! !!GplToken methodsFor: 'testing' stamp: 'kf 4/26/2009 14:51'!isNull	^self isString and: [self fragment = '""'].! !!GplToken methodsFor: 'testing' stamp: 'kf 4/24/2009 10:06'!isNumber	^self type = #number.! !!GplToken methodsFor: 'testing' stamp: 'kf 4/23/2009 17:36'!isOperator	^self type = #operator.! !!GplToken methodsFor: 'testing' stamp: 'kf 5/30/2009 10:09'!isProcedureCall	^self leftTokens isEmpty! !!GplToken methodsFor: 'testing' stamp: 'kf 4/26/2009 14:57'!isString	^self type = #string.! !!GplToken methodsFor: 'testing' stamp: 'kf 4/25/2009 22:07'!isVariableAllowed	^self type = #unresolved or: [self type = #variable].! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/24/2009 11:38'!addSubToken: aGplToken	subtokens ifNil: [subtokens := OrderedCollection new].	subtokens add: aGplToken.	parser ifNil: [parser := aGplToken parser].	type ifNil: [self type: #vector].	! !!GplToken methodsFor: 'accessing' stamp: 'kf 5/21/2009 21:09'!argumentType: aSymbol	self assert: (#(monadic niladic dyadic) includes: aSymbol).	argumentType := aSymbol.	! !!GplToken methodsFor: 'accessing' stamp: 'kf 5/29/2009 10:50'!depth	^self depthOfParlen + self depthOfSubscript.! !!GplToken methodsFor: 'accessing' stamp: 'kf 5/29/2009 21:21'!depthOfOpen: openFragment close: closeFragment	| allTokens level |	allTokens := self parser tokens.	level := 0.	allTokens do: [:each |		each fragment = openFragment			ifTrue: [				level := level + 1.				each = self ifTrue: [^level]].		each fragment = closeFragment			ifTrue: [				each = self ifTrue: [^level].				level := level - 1].		each = self ifTrue: [^level].].	^0.! !!GplToken methodsFor: 'accessing' stamp: 'kf 5/29/2009 10:35'!depthOfParlen	^self depthOfOpen: '(' close: ')'. ! !!GplToken methodsFor: 'accessing' stamp: 'kf 5/29/2009 10:35'!depthOfSubscript	^self depthOfOpen: '[' close: ']'. ! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/30/2009 17:04'!end	self hasSubTokens		ifTrue: [^(subtokens collect: [:token | token end]) max].	^end.	! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/30/2009 17:04'!end: anInteger	end := anInteger! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/22/2009 17:22'!fragment	^parser fragmentOfRange: self.! !!GplToken methodsFor: 'accessing' stamp: 'kf 5/22/2009 01:31'!fragmentForInspect	| base |	base := self fragment.	(base = ':=')		ifTrue: [			| leftTokens subScriptClose|			leftTokens := self leftTokens.			subScriptClose := leftTokens detect: [:each | each fragment = ']'] ifNone:[nil].			subScriptClose ifNotNil: [base := '[]:='].			].	argumentType ifNotNil: [		base := base, ' (', argumentType asString, ')'].	^base.! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/24/2009 23:34'!leftFragment	self start = 1		ifTrue: [^''].	^parser source copyFrom: 1 to: self start - 1.! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/24/2009 23:55'!leftTokens	^GplParser tokensFrom: self leftFragment! !!GplToken methodsFor: 'accessing' stamp: 'kf 5/29/2009 16:34'!leftTokensOfDepth: aDepth	^self leftTokens select: [:each | each depth = aDepth]! !!GplToken methodsFor: 'accessing' stamp: 'kf 5/29/2009 11:00'!leftTokensOfSameDepth	^self leftTokensOfDepth: self depth! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/30/2009 17:05'!length	^end - start + 1! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/24/2009 11:34'!parser	^parser! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/24/2009 10:01'!parser: aGplParser2	parser := aGplParser2.! !!GplToken methodsFor: 'accessing' stamp: 'kf 5/21/2009 21:37'!postfixExpr	(self fragment = '[')		ifTrue: [^'[]'].	^self fragmentForInspect.! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/24/2009 23:37'!rightFragment	self end = parser source size		ifTrue: [^''].	^parser source copyFrom: self end + 1 to: parser source size.! !!GplToken methodsFor: 'accessing' stamp: 'kf 5/29/2009 21:26'!rightTokens	| newTokens |	newTokens := GplParser tokensFrom: self rightFragment.	newTokens do: [:each |		each parser: self parser.		each start: self end + each start.		each end: self end + each end].	^newTokens.! !!GplToken methodsFor: 'accessing' stamp: 'kf 5/29/2009 16:34'!rightTokensOfDepth: aDepth	^self rightTokens select: [:each | each depth = aDepth]! !!GplToken methodsFor: 'accessing' stamp: 'kf 5/29/2009 10:59'!rightTokensOfSameDepth	^self rightTokensOfDepth: self depth! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/30/2009 17:21'!start	self hasSubTokens		ifTrue: [^(subtokens collect: [:token | token start]) min].	^start.! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/30/2009 17:04'!start: anInteger	start := anInteger! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/30/2009 17:03'!start: startInteger end: endInteger type: typeSymbol	start := startInteger.	end := endInteger.	type := typeSymbol! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/30/2009 17:08'!type	(type = #unresolved)		ifTrue: [self type: self lookupType].	^type.				! !!GplToken methodsFor: 'accessing' stamp: 'kf 4/30/2009 17:03'!type: aSymbol	type := aSymbol! !!GplToken methodsFor: 'conversion' stamp: 'kf 5/23/2009 19:31'!asGplValue	| clazz |	self isNull ifTrue: [^ GdsNull instance].	self isString ifTrue: [^ GdsString fromLiteral: self fragment].	self isOperator ifTrue: [^ self fragment asLowercase asSymbol].	clazz := GdsDglType bestClassOfStatement: self fragment.	clazz ifNotNil: [^ clazz fromLiteral: self fragment].	self type = #vector 		ifTrue: [^ GdsVector withAll: (subtokens collect: [:t | t asGplValue])].	^ self! !!GplToken methodsFor: 'initialization' stamp: 'kf 4/22/2009 18:33'!initialize	super initialize.	! !!GplToken methodsFor: 'private' stamp: 'kf 9/16/2009 16:12'!lookupType	| fragment |	fragment := self fragment. 	(GplParser isNumberFragment: fragment)		ifTrue: [^#number].	(GplParser isOperatorFragment: fragment)		ifTrue: [^#operator].	('()' includes: fragment first)		ifTrue: [^#paren].	('[]' includes: fragment first)		ifTrue: [^#bracket].	(self class isReservedKeyword: fragment)		ifTrue: [^#reserved.].	(self class isBuiltinMethod: fragment)		ifTrue: [^#builtinMethod.].	(self class isGdsiiMethod: fragment)		ifTrue: [^#gdsiiMethod].	(self fragment beginsWith: '|')		ifTrue: [^#comment.].			((self fragment beginsWith: '`') and: [self fragment endsWith: ''''])		ifTrue: [^#comment.].			(self fragment allSatisfy: [: each |  { Character space . Character tab } includes: each ])		ifTrue: [^#space].			(self fragment beginsWith: '"')		ifTrue: [^#string.].	^#unresolved.					! !!GplToken methodsFor: 'printing' stamp: 'kf 5/21/2009 21:09'!printOn: aStream	"fragment = #cr ifTrue: [^aStream nextPutAll: 'CR']".	aStream nextPutAll: '['.		aStream nextPutAll: self start printString.	aStream nextPutAll: ','.		aStream nextPutAll: self end printString.		aStream nextPutAll: ']'.	aStream nextPutAll: '('.	aStream nextPutAll: self type printString.	aStream nextPutAll: ','.	aStream nextPutAll: self fragmentForInspect printString.	aStream nextPutAll: ')'.		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplToken class	instanceVariableNames: ''!!GplToken class methodsFor: 'specs' stamp: 'kf 4/20/2009 20:43'!builtinMethods	^	#('TYPEOF' 'SHAPE' 'RANK' 'LENGTH' 'SIZE' 'IOTA' 'INDEXOF' 'GRADEUP' 'GRADEDOWN' 'SORT' 'SORTDOWN' 'ABS' 'FLOOR' 'CEILING' 'EXP' 'LN' 'PI' 	'SIN' 'COS' 'TAN' 'ARCTAN' 'NOT'),	#('RESHAPE' 'IN' 'INDEXOF' 'INDECES_OF' 'MOD' 'MIN' 'MAX' 'MIN_MAX' 'POWER'	'LOGBASE' 'EQ' 'LT' 'GT' 'LEQ' 'GEQ' 'NEQ' 'AND' 'OR' 'NAND' 'NOR' 'XOR'	'BITAND' 'BITOR' 'BITXOR' )! !!GplToken class methodsFor: 'specs' stamp: 'kf 4/25/2009 17:29'!flowControlKeywords	^#(	'IF' 'THEN' 'ELSE' 'ELIF' 'ENDIF'	'FOR' 'WHILE' 'DO' 'ENDDO' 'UNTIL'	'GOTO'	'SWITCH' 'OF' 'CASE' 'OUT' 'ENDSWITCH'	)! !!GplToken class methodsFor: 'specs' stamp: 'kf 4/20/2009 20:42'!gdsiiMethods	^	#('BLUE' 'CYAN' 'GREEN' 'MAGENTA' 'RED' 'WHITE' 'YELLOW'),	#('ABSANGLE' 'ABSMAG' 'ABSTATION' 'ABSWIDTH' 'ADDPLEX' 'ADDRT' 'ANGLE' 'ARC' 'AREF' 'AREFMARK' 'ASCALE' 'ASHAPE' 'AUTOHOLD' 'AND' 'ANDNOT' 'BACKUP' 'BINDATTR' 'BINDFONTS' 'BOUNDARY' 'BOUNDARYMARK' 'BOX' 'BOXTYPE' 'BROKEN' 'BSCALE' 'BSTRUCT' 'BUTTON' 'BUTTONMODE' 'BITAND' 'BITOR' 'BITXOR' 'BOUNDARYAREA' 'CE' 'CH' 'CHECKEXTERIOR1' 'CHECKEXTERIOR2' 'CHECKINTERIOR' 'CIRCLE' 'CIRCLESIZE' 'CLEAR' 'CLOSE' 'CLOSELIB' 'CLOSEREF1' 'CLOSEREF2' 'CLRPROP' 'COLORBY''COMMANDS' 'CONTEXT' 'COORDS' 'CRACL' 'CSTRUCT' 'CUTPATHIN' 'CUTPATHOUT' 'CARTESIAN' 'CEKEY' 'CFORMAT' 'CHECKAREA' 'CLOSESTTO' 'CRTTYPE' 'DACL' 'DASHED' 'DATACOPY' 'DATADELETE' 'DATADRAW' 'DATAMAGNIFY' 'DATAMOVE' 'DATAOVERSIZE' 'DATAPAN' 'DATAREDRAW' 'DATAREFLECT' 'DATAROTATE' 'DATASETVIEW' 'DATATYPE' 'DATAVIEWMOVE' 'DATAZOOM' 'DB' 'DE' 'DEFATTR' 'DEFMODE' 'DFUNCTION' 'DIGMODE' 'DIRECTORY' 'DISK' 'DISPLAYSTAT' 'DLN' 'DOTTED' 'DS' 'DSTRUCT' 'DVERT' 'DATAEXTENT' 'DATAVIEW' 'DAY' 'DIGIN' 'DROUND' 'DSELECT' 'EDATA' 'EDGE' 'ENAME' 'ENDLOG' 'ENTERTEXT' 'EREF' 'ESTAT' 'ESTRUCT' 'EXPLODE' 'EXPUNGE' 'EXECUTE' 'EXPINPUT' 'FCCONT' 'FCHATR' 'FCOPY' 'FDELETE' 'FILLA' 'FILLBY' 'FILLC' 'FILLD' 'FILLET' 'FILLSET' 'FINDDATA' 'FINIT' 'FLAYER' 'FLAYEROFF' 'FLAYERON' 'FLINK' 'FLIST' 'FONT' 'FONTINFO' 'FPRINT' 'FRELEASE' 'FRENAME' 'FUNCTIONS' 'FUNLINK' 'FETCH' 'FILEINFO' 'FILLB' 'FORMAT' 'GEDMODE' 'GET' 'GETITEM' 'GETP' 'GPL' 'GRID' 'GSCALE' 'GEDCOORDS' 'GEDELEMENT' 'GETEL' 'GLOBALTOLOCAL' 'GTIME' 'HARDCOPY' 'HARDLOCKS' 'HELP' 'HORIZFIRST' 'IB' 'ICOPY' 'ID' 'IDADD' 'IDCANGLE' 'IDCBOXTYPE' 'IDCDATATYPE' 'IDCFONT' 'IDCLAYER' 'IDCLEAR' 'IDCMAG' 'IDCNODETYPE' 'IDCOPY' 'IDCPATHTYPE' 'IDCTEXTTYPE' 'IDCWIDTH' 'IDDELETE' 'IDEXPLODE' 'IDMARK' 'IDMOVE' 'IDOVERSIZE' 'IDPATHEXP' 'IDREFLECT' 'IDROTATE' 'IDSTRUCT' 'IDSUMMARY' 'IDTEXTEXP' 'IDWINDOW' 'IDWINSTRUCT' 'IE' 'IFILE' 'IITEM' 'IMOVE' 'INACL' 'INFORM' 'INITDISPLAY' 'INITLIB' 'INTCHECKMODE' 'INTRT' 'ISTAT' 'ITEM' 'ITEMCOPY' 'ITEMMARK' 'ITEMREFLECT' 'ITEMREVERSE' 'ITEMROTATE' 'IDKEYS' 'INDICESOF' 'INPUTMASK' 'INSIDEBOUNDARY' 'INTERSECT' 'JOBABORT' 'JOBCREATE' 'JOBINFO' 'JOBLOG' 'JOBPRIORITY' 'JOBSTART' 'JOBSUSPEND' 'JOIN' 'JOBID' 'KEYSTRUCT' 'KEYCE' 'KEYMARK' 'LACL' 'LASTCOORD' 'LAYER' 'LAYERTYPE' 'LEVEL' 'LISTATTR' 'LISTDISPLAY' 'LISTGEN' 'LISTLIB' 'LISTREF1' 'LISTREF2' 'LOAD' 'LOCALTOGLOBAL' 'LOG' 'LOWERCASE' 'LSTAT' 'LAYERSIN' 'LINEINTERSECT' 'MAG' 'MARK' 'MARKSIZE' 'MASKFREE' 'MASKS' 'MASKSAVE' 'MEMORY' 'MENU' 'MENUMOVE' 'MERGELIB' 'MOVE' 'MOVEPOINT' 'MASKRESTORE' 'MEMBER' 'MINMAX' 'MSELECT' 'NAMES' 'NEWANGLE' 'NEWBOXTYPE' 'NEWDATATYPE' 'NEWFONT' 'NEWLAYER' 'NEWMAG' 'NEWNODETYPE' 'NEWPATHTYPE' 'NEWTEXTTYPE' 'NEWUNITS' 'NEWWIDTH' 'NODE' 'NODETYPE' 'NAMESBOUND' 'NAMESOPEN' 'NSELECT' 'OCTAGONAL' 'ODATA' 'ONAME' 'OPENDISPLAY' 'OPENLIB' 'OPENREF1' 'OPENREF2' 'OPTIONS' 'OREF' 'ORTHINT' 'OSTRUCT' 'OUTFORM' 'OUTFORM3' 'OUTPUTCHANGE' 'OUTPUTMASK' 'OUTPUTPATH' 'OUTPUTVIEW' 'OR' 'PAN' 'PATH' 'PATHEDGE' 'PATHMARK' 'PATHTYPE' 'PAUSE' 'PLEXMODE' 'PLOTSTAT' 'PROPVALUE' 'PUT' 'PUTALL' 'PATHBOUNDARY' 'PLEX' 'POLAR' 'PUTEL' 'QUIT' 'R3' 'RACL' 'RCSTRUCT' 'RECOVERLIB' 'REDO' 'REDRAW' 'REFL' 'REMOVE' 'REVERT' 'RJOB' 'RMENU' 'RS' 'RSCALE' 'RSCREEN' 'RSTRUCT' 'RT' 'RTDIGMODE' 'RULER' 'ROUND' 'ROUNDMASK' 'SAVE' 'SAVEDISPLAY' 'SB' 'SBTYPE' 'SBTYPEOFF' 'SBTYPEON' 'SCELL' 'SDTYPE' 'SDTYPEOFF' 'SDTYPEON' 'SEGS' 'SETCOLORS' 'SETDIG' 'SETLEVEL' 'SETTAB' 'SETVIEW' 'SHOWDEFAULTS' 'SHOWREFS' 'SHOWSNAPS' 'SKIND' 'SKINDOFF' 'SKINDON' 'SLAYER' 'SLAYEROFF' 'SLAYERON' 'SLIMSIZE' 'SNAME' 'SNAP' 'SNAPCE' 'SNAPSIZE' 'SNTYPE' 'SNTYPEOFF' 'SNTYPEON' 'SOLID' 'SPLIT' 'SPOOLQ' 'SREF' 'SREFMARK' 'SSTAT' 'SSTRUCT' 'STADPY' 'START' 'STRAIGHT' 'STREAMOUT' 'STRETCH' 'STRETCHCELL' 'STTYPE' 'STTYPEOFF' 'STTYPEON' 'STYLEBY' 'SUBRT' 'SUBS' 'SUMMARY' 'SYSDPY' 'SYSTAT' 'SLEEP' 'STADPYINFO' 'STANUM' 'STRUCINFO' 'STRUCLIST' 'STRUCOPEN' 'STRUCREFS' 'SUBSET' 'SYSN' 'TABMODE' 'TEMPLATE' 'TEMPLATEMARK' 'TEMPREF1' 'TEMPREF2' 'TEXT' 'TEXTFONT' 'TEXTMARK' 'TEXTTYPE' 'TIME' 'TJUST' 'TREE' 'TSTRUCT' 'TABTYPE' 'TEXTINPUT' 'TOD' 'UNDO' 'UNGET' 'UNID' 'UNIDWINDOW' 'UNMARK' 'UPDISPLAY' 'UPLIB' 'UPLOWCASE' 'UPPERCASE' 'USER' 'USERPROP' 'USTRUCT' 'UNDERSIZE' 'UNION' 'USELECT' 'VBTYPE' 'VBTYPEOFF' 'VBTYPEON' 'VDTYPE' 'VDTYPEOFF' 'VDTYPEON' 'VECTORCOUNT' 'VERTFIRST' 'VIEWEXTENT' 'VIEWMOVE' 'VKIND' 'VKINDOFF' 'VKINDON' 'VLAYER' 'VLAYEROFF' 'VLAYERON' 'VLEVELS' 'VLT' 'VMODE' 'VNTYPE' 'VNTYPEOFF' 'VNTYPEON' 'VSTRUCT' 'VTTYPE' 'VTTYPEOFF' 'VTTYPEON' 'VARS' 'VIEWWINDOW' 'WIDTH' 'WINCOPY' 'WINDELETE' 'WINFENCE' 'WINMOVE' 'WINOPTIONS' 'WINSTRETCH' 'WINSTRUCT' 'WIPE' 'WIPEALL' 'WITEM' 'WSCALE' 'WSCREEN' 'WASTAT' 'XSCALE' 'XOR' 'YSCALE' 'ZOOM' 'ZSCALE')! !!GplToken class methodsFor: 'specs' stamp: 'kf 9/9/2012 08:29'!implementedDyadicMethods	^#('RESHAPE')! !!GplToken class methodsFor: 'specs' stamp: 'kf 9/9/2012 08:28'!implementedMonadicMethods	^#('ABS' 'FLOOR' 'CEILING' 'EXP' 'LN' 'PI' 'SIN' 'COS' 'TAN' 'ARCTAN' 'NOT')! !!GplToken class methodsFor: 'specs' stamp: 'kf 9/9/2012 08:37'!inspectMonadicMethods	^#('TYPEOF' 'SHAPE' 'RANK' 'SIZE' 'LENGTH')! !!GplToken class methodsFor: 'specs' stamp: 'kf 4/25/2009 17:23'!methodTypeKeywords	^#('NILADIC' 'MONADIC' 'DYADIC')! !!GplToken class methodsFor: 'specs' stamp: 'kf 4/25/2009 17:25'!methodUnitKeywords	^#('PROCEDURE' 'FUNCTION' 'ENDSUB')! !!GplToken class methodsFor: 'specs' stamp: 'kf 4/25/2009 17:40'!programOnlyKeywords	^((self reservedKeywords,	#('RANGE')) reject: [:word |		#('LOCAL' 'GLOBAL') includes: word		]) asArray.! !!GplToken class methodsFor: 'specs' stamp: 'kf 9/9/2012 08:27'!reservedKeywords	"GplToken reservedKeywords"	^self methodUnitKeywords,	self methodTypeKeywords,	self flowControlKeywords,	self storageScopeKeywords.! !!GplToken class methodsFor: 'specs' stamp: 'kf 4/20/2009 12:03'!storageScopeKeywords	^#('EXTERNAL' 'LOCAL' 'GLOBAL')! !!GplToken class methodsFor: 'testing' stamp: 'kf 4/19/2009 22:07'!isBuiltinMethod: aString	^self builtinMethods includes: aString asUppercase.! !!GplToken class methodsFor: 'testing' stamp: 'kf 4/20/2009 20:43'!isGdsiiMethod: aString	^self gdsiiMethods includes: aString asUppercase.! !!GplToken class methodsFor: 'testing' stamp: 'kf 4/25/2009 17:43'!isProgramOnlyKeyword: aString	^self programOnlyKeywords includes: aString asUppercase.! !!GplToken class methodsFor: 'testing' stamp: 'kf 4/19/2009 21:54'!isReservedKeyword: aString	^self reservedKeywords includes: aString asUppercase.! !!GplToken class methodsFor: 'instance creation' stamp: 'kf 4/26/2009 12:54'!newFromTokens: aGplTokens	|newToken|	GplParser assertGplTokens: aGplTokens.	self assert: [aGplTokens isEmpty not].	(aGplTokens size = 1) ifTrue: [^aGplTokens first]. "is a scalar"	newToken := self new.	aGplTokens do: [:each | newToken addSubToken: each].	^newToken! !!GplToken class methodsFor: 'instance creation' stamp: 'kf 4/22/2009 17:24'!start: s end: e type: aSymbol parser: aGplParser2		^self new		start: s end: e type: aSymbol;		parser: aGplParser2;		yourself! !GdsObject subclass: #GplTokenHandler	instanceVariableNames: 'stack showsLog'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Kernel'!!GplTokenHandler methodsFor: 'analysis-postfix' stamp: 'kf 5/29/2009 11:22'!beforeEvaluteTokens: aGplTokens	GplParser assertGplTokens: aGplTokens.	self resetStack.! !!GplTokenHandler methodsFor: 'analysis-postfix' stamp: 'kf 5/29/2009 11:11'!pop	| result |	result := stack last.	stack := stack allButLast.	^result.! !!GplTokenHandler methodsFor: 'analysis-postfix' stamp: 'kf 5/29/2009 11:11'!push: aToken	stack add: aToken.! !!GplTokenHandler methodsFor: 'private' stamp: 'kf 5/30/2009 09:28'!clientPrompt	^'? '! !!GplTokenHandler methodsFor: 'accessing' stamp: 'kf 6/5/2009 17:37'!debugLog: aObject	self showsLog ifFalse: [^self].	Transcript cr; show: aObject.	! !!GplTokenHandler methodsFor: 'accessing' stamp: 'kf 5/29/2009 11:13'!showsLog	^showsLog! !!GplTokenHandler methodsFor: 'accessing' stamp: 'kf 5/29/2009 11:13'!showsLog: aBoolean	self assert: [aBoolean isKindOf: Boolean]. 	showsLog := aBoolean.	! !!GplTokenHandler methodsFor: 'initialize-release' stamp: 'kf 5/29/2009 11:17'!initialize	super initialize.	showsLog := false.	self resetStack.	! !!GplTokenHandler methodsFor: 'initialize-release' stamp: 'kf 5/29/2009 11:17'!resetStack	stack := OrderedCollection new.	! !!GplTokenHandler methodsFor: 'syntax check' stamp: 'kf 5/30/2009 09:31'!notImplementedToken: aGplToken	^self syntaxMessage: 'RESERVED BUT NOT IMPLEMENTED' token: aGplToken.! !!GplTokenHandler methodsFor: 'syntax check' stamp: 'kf 5/30/2009 09:29'!syntaxMessage: aMessage token: aGplToken	^String streamContents: [:s |		(aGplToken start + (self clientPrompt size)) - 1 timesRepeat: [s nextPut: Character space].		aGplToken fragment size timesRepeat: [s nextPut: $^].		s nextPut: Character space.		s nextPutAll: (aMessage,': ', aGplToken fragment).]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplTokenHandler class	instanceVariableNames: ''!GplTokenHandler subclass: #GplEvaluter	instanceVariableNames: 'history argStack varMap postfixTokens suspendContext resultMap'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Kernel'!!GplEvaluter commentStamp: 'kf 4/25/2009 16:08' prior: 0!A GplEvaluter is GPLII Expression evaluter.Instance Variables	argStack:		<OrderedCollection>	history:		<OrderedCollection>	outTokens:		<OrderedCollection>	stack:		<OrderedCollection>argStack	- postfix notation argument or result value stackhistory	- expression input historyoutTokens	- infix to postfix transform work areastack	- infix to postfix transform analysis stack!!GplEvaluter methodsFor: 'private' stamp: 'kf 4/24/2009 11:01'!assertGplTokens: aCollection	self assert: [aCollection allSatisfy: [:each | each isMemberOf: GplToken]].	! !!GplEvaluter methodsFor: 'private' stamp: 'kf 4/24/2009 11:03'!assertGplValues: aCollection	self assert: [aCollection allSatisfy: [:each | each isKindOf: GdsDglType]].	! !!GplEvaluter methodsFor: 'private' stamp: 'kf 4/24/2009 10:46'!indexes: aGplTokens ofType: aSymbol	| colIndex |	colIndex := OrderedCollection new.	aGplTokens		doWithIndex: [:token :index |			token type = aSymbol ifTrue: [colIndex add: index].].	^colIndex asArray.! !!GplEvaluter methodsFor: 'private' stamp: 'kf 4/24/2009 10:20'!numberTokens: aGplTokens	^aGplTokens select: [:token | token isNumber].! !!GplEvaluter methodsFor: 'private' stamp: 'kf 5/22/2009 10:00'!voidReturn	^GdsNull instance.! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 5/26/2009 17:08'!evaluteArithmetic: aGplToken 	(aGplToken fragmentForInspect endsWith: '(dyadic)') 		ifTrue: [^ self evaluteDyadicArithmetic: aGplToken].	(aGplToken fragmentForInspect endsWith: '(monadic)') 		ifTrue: [^ self evaluteMonadicArithmetic: aGplToken].	^ self error: 'ILLIGAL ARGUMENT SIZE'! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 5/19/2009 23:38'!evaluteAsVector: aGplToken	| arg1 |	arg1 := self popArg.	^arg1 asGplValue asVector.! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 5/22/2009 10:51'!evaluteAssign: aGplToken	|  gv1 variableObject valueArg variableArg |	self assert: [aGplToken fragment = ':='].	valueArg := self popArg.	variableArg := self popArg.	gv1 := valueArg asGplValue copy.	variableObject := self getVariable: variableArg wantsStrictDeclare: false.	variableObject gplValue: gv1.	(variableArg isMemberOf: GplToken)		ifTrue: [			variableArg type: #variable].	(aGplToken == postfixTokens last)		ifTrue: [^self voidReturn].	^variableObject.! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 5/19/2009 01:29'!evaluteBuiltinDyadic: aGplToken	^self evaluteReshape: aGplToken			! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 4/27/2009 17:56'!evaluteBuiltinMonadic: aGplToken	| sel  arg1  gv1|	sel := aGplToken fragment asLowercase asSymbol.	sel := (sel = #arctan) ifTrue: [#arcTan] ifFalse: [sel]. "special case"	arg1 := self popArg.	gv1 := arg1 asGplValue.	^gv1 perform: sel					! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 6/5/2009 17:42'!evaluteDyadicArithmetic: aGplToken 	| arg1 arg2 real1 real2 result gv1 gv2 |	arg2 := self popArg.	arg1 := self popArg.	gv1 := arg1 asGplValue.	gv2 := arg2 asGplValue.	self debugLog: {  gv1. gv2}.	(gv1 rank = 0 and: [gv2 rank = 0]) 		ifTrue: 			[real1 := gv1 asSmalltalkValue asFloat.			real2 := gv2 asSmalltalkValue asFloat.			result := (real1 perform: (self class arithmeticSelector: aGplToken)						with: real2) asFloat.			^ GdsReal fromLiteral: result asString]		ifFalse: 			[result := gv1 perform: aGplToken fragment asSymbol with: gv2.			^ result]! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 4/27/2009 21:48'!evaluteInspectMonadic: aGplToken	| sel  arg1  gv1|	sel := aGplToken fragment asLowercase capitalized.	sel := ('gplValueOf', sel) asSymbol.	arg1 := self popArg.	gv1 := arg1 asGplValue.	^gv1 perform: sel					! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 5/27/2009 16:19'!evaluteJoinVector: aGplToken 	| rightArg leftArg leftArray rightArray leftType rightType |	rightArg := self popArg.	leftArg := self popArg.	leftArray := leftArg asGplValue.	rightArray := rightArg asGplValue.	leftType := leftArray typeString.	rightType := rightArray typeString.	(leftType = 'CHAR' and: [rightType = 'CHAR']) 		ifTrue: 			[^ GdsString 				withAll: leftArray asVector elements , rightArray asVector elements].	(leftType ~= 'CHAR' and: [rightType ~= 'CHAR']) 		ifTrue: 			[^ GdsVector 				withAll: leftArray asVector elements , rightArray asVector elements].	^ self runtimeError: 'ILLIGAL TYPE CPNVERSION'! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 5/23/2009 19:31'!evaluteList: aGplToken 	| rightArg leftArg result leftValue rightValue |	self fillListRightArgument: aGplToken.	rightArg := self popArg.	self fillListLeftArgument: aGplToken.	leftArg := self popArg.	result := GdsList new.	leftValue := leftArg asGplValue.	rightValue := rightArg asGplValue.	result add: leftValue.	result add: rightValue.	^ result! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 6/7/2009 17:57'!evaluteMonadicArithmetic: aGplToken 	| arg1 gv1 |	arg1 := self popArg.	gv1 := arg1 asGplValue.	aGplToken fragment = '+' ifTrue: [^ gv1 asGdsFloating].	aGplToken fragment = '-' ifTrue: [^ gv1 negated].	aGplToken fragment = '*' ifTrue: [^ gv1 sign].	aGplToken fragment = '%' ifTrue: [^ gv1 reciprocal]! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 5/27/2009 16:30'!evaluteReshape: aGplToken 	| argRight argLeft gvRight gvLeft columnCount rowCount mustIntegerBlock |	argRight := self popArg.	argLeft := self popArg.	gvLeft := argLeft asGplValue.	gvRight := argRight asGplValue.	gvLeft := gvLeft asVector.	gvRight := gvRight asVector.	mustIntegerBlock := [:v | v isInteger ifFalse: [self runtimeError: 'SUBSCRIPT VALUE MUST BE INTEGLAL']].	gvLeft size = 1 		ifTrue: [			columnCount := (gvLeft at: 1) asSmalltalkValue.			mustIntegerBlock value: columnCount.			^ GdsMatrix fromGdsVector: gvRight col: columnCount].	gvLeft size = 2 		ifTrue: [			rowCount := (gvLeft at: 1) asSmalltalkValue.			columnCount := (gvLeft at: 2) asSmalltalkValue.						mustIntegerBlock value: rowCount.			mustIntegerBlock value: columnCount.			^ GdsMatrix  fromGdsVector: gvRight  row: rowCount col: columnCount].	^ self runtimeError: 'INVALID SHAPE FORMAT'! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 6/5/2009 17:43'!evaluteSubscript: aGplToken 	(self hasMoreAssign: aGplToken)		ifTrue: [			self debugLog: '*** skip subscription return'.			^self popArg.].	^self evaluteSubscriptReturn: aGplToken.! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 5/25/2009 23:01'!evaluteSubscriptAssign: aGplToken 	| assignValue valueArg variableArg subscriptArg subscriptValue target returnValue |	self assert: [aGplToken fragment = ':='].	valueArg := self popArg.	subscriptArg := self popArg.	variableArg := self popArg.	assignValue := valueArg asGplValue copy.	subscriptValue := subscriptArg asGplValue.	returnValue := assignValue.	target := (self getVariable: variableArg wantsStrictDeclare: true) 				asGplValue.	returnValue :=  target atSubscriptWithCheck: subscriptValue put: assignValue.	aGplToken == postfixTokens last ifTrue: [^ self voidReturn].	^ returnValue! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 5/25/2009 23:00'!evaluteSubscriptReturn: aGplToken 	| arg1 arg2 target subscript |	arg2 := self popArg.	arg1 := self popArg.	target := arg1 asGplValue.	subscript := arg2 asGplValue.	^target atSubscriptWithCheck: subscript.! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 5/21/2009 22:12'!evaluteVector: aGplToken 	(aGplToken fragmentForInspect endsWith: '(dyadic)')		ifTrue: [^ self evaluteJoinVector: aGplToken].	(aGplToken fragmentForInspect endsWith: '(monadic)')		ifTrue: [^ self evaluteAsVector: aGplToken].	^self error: 'ILLIGAL ARGUMENT SIZE'.! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 5/23/2009 17:26'!fillListLeftArgument: aGplToken 	| leftTokens missingLeft |		leftTokens := aGplToken leftTokens.	missingLeft := leftTokens 		ifEmpty: [true]		ifNotEmpty: [				('([' includes: leftTokens last fragment first) ].	missingLeft ifTrue: [self pushArg: GdsNull instance].! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 5/23/2009 17:26'!fillListRightArgument: aGplToken 	| rightTokens missingRight |		rightTokens := aGplToken rightTokens.	missingRight := rightTokens 		ifEmpty: [true]		ifNotEmpty: [				('])' includes: rightTokens first fragment first) ].	missingRight ifTrue: [self pushArg: GdsNull instance].! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 5/22/2009 09:51'!getVariable: variableArg wantsStrictDeclare: aBoolean	|  variableObject  varName |			varName := (variableArg isKindOf: GplToken)		ifTrue: [variableArg fragment]		ifFalse: [variableArg name].	aBoolean		ifTrue: [			(self hasVariableName: varName)				ifFalse: [^self error: 'VARIABLE NOT DECLEARED']].	variableArg isVariableAllowed ifFalse: [^self error: 'CAN''T ASSIGN TO:',  varName].	variableObject := self variableNamed: varName.	^variableObject! !!GplEvaluter methodsFor: 'evaluter-inside' stamp: 'kf 5/28/2009 21:23'!hasMoreAssign: aGplToken 	"^((outTokens last fragment = ':=') and: [aGplToken start < outTokens last start  ])"	| tokens closeToken level |	tokens := aGplToken rightTokens.	tokens ifEmpty: [^false].	closeToken := nil.	level := 1.	tokens do: [:each |		each fragment = '[' ifTrue: [level := level + 1].		each fragment = ']' 			ifTrue: [				level := level - 1.				(level = 0 and: [closeToken isNil])				 	ifTrue: [closeToken := each]]].	closeToken 		ifNotNil: [			tokens := tokens := closeToken rightTokens].	^(tokens detect: [:each | each fragment = ':='] ifNone: [nil]) isNil not.! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 6/7/2009 18:12'!evaluteAsString: aBlock	| result reply |	result := nil.	reply := ''.	[result := aBlock value] 		on: Error 		do: [:ex | 			(ex isKindOf: GplPromptException)				ifTrue: [ex pass].			^ex messageText].	result ifNotNil: [reply := result gplString].	^reply.! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 6/7/2009 14:10'!evaluteConsoleLine: aString	| tokens reply result |	reply := aString.	result := nil.	aString		ifNotEmpty: [			(aString first = $\)				ifTrue: [					^self 						handleForKey: (aString allButFirst)						line: self lastEvalutedLine.]].		history add: aString.	tokens := self tokensFrom: aString.	[self syntaxCheck: tokens] on: Error do: [:ex | ^ex messageText].	^self evaluteAsString: [self evaluteLine: aString].! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 6/5/2009 15:07'!evaluteLine: aString	| tokens |	aString ifEmpty:  [^GdsNull instance].	argStack := nil.	tokens := self tokensFrom: aString.	tokens := self vectorAnalysisFromTokens: tokens.	^self evaluteTokens: tokens.! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 6/7/2009 11:19'!evalutePostfixStream: aPostfixStream	| token result |	argStack ifNil: [argStack := OrderedCollection new].	[aPostfixStream atEnd]		whileFalse: [			token := aPostfixStream next.			self handleToken: token.].	result := self popArg asGplValue.	argStack ifNotEmpty: [self error: 'EXPRESSION PARSED INCORRECTLY'].	^result.! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 6/7/2009 11:19'!evalutePostfixTokens: aGplTokens	^self evalutePostfixStream:  (ReadStream on: aGplTokens).! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 6/5/2009 17:44'!evaluteTokens: aGplTokens	| postfixGenerator |	postfixGenerator := GplPostfix new.	postfixGenerator showsLog: self showsLog.	postfixTokens := postfixGenerator translateToPostfixFromTokens: aGplTokens.	self debugLog: postfixTokens printString.	^self evalutePostfixTokens: postfixTokens.! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 9/9/2012 08:55'!handleToken: aToken 	| result |	self showsLog 		ifTrue: [self printArgStack: aToken].					result := self handleTokenResult: aToken.		result isSymbol		ifTrue: [^ self error: (self notImplementedToken: aToken)].		self pushArg: result.	! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 9/9/2012 08:50'!handleTokenResult: aToken 	| handler |	handler := GplHandler fromCommand: aToken fragment evaluter: self.	handler 		ifNotNil: [^handler evaluteToken: aToken].	(self isOperandToken: aToken) 		ifTrue: [^aToken].	aToken isArithmeticOperator 		ifTrue: [^self evaluteArithmetic: aToken].	self isInteractive 		ifTrue: [aToken isVariableAllowed ifTrue: [^aToken]].	aToken fragment = '[' 		ifTrue: [^self evaluteSubscript: aToken].			aToken fragmentForInspect = '[]:=' 		ifTrue: [^self evaluteSubscriptAssign: aToken].	aToken fragment = ':=' 		ifTrue: [^self evaluteAssign: aToken].	aToken fragment = ',' 		ifTrue: [^self evaluteVector: aToken].	aToken fragment = ';' 		ifTrue: [^self evaluteList: aToken].	aToken isBuiltinMonadic 		ifTrue: [^self evaluteBuiltinMonadic: aToken].	aToken isBuiltinDyadic 		ifTrue: [^self evaluteBuiltinDyadic: aToken].	aToken isInspectMonadic 		ifTrue: [^self evaluteInspectMonadic: aToken].	aToken fragment = #cr 		ifTrue: [^self voidReturn].	^#notImplemented! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 4/25/2009 22:41'!hasVariableName: aVariableName	varMap ifNil: [^false].	^varMap includesKey: aVariableName.! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 6/10/2009 16:43'!notConsumedTokens: aGplToken 	| restSize ownPos depth |	depth := aGplToken depth.	ownPos := self postfixIndexOf: aGplToken.	restSize := postfixTokens size - ownPos.	(restSize = 0)		ifTrue: [^#() copy].	^(postfixTokens allButFirst: ownPos) select: [:each |			         each depth = depth 			and: [self isDyadic: each] ].! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 6/10/2009 16:07'!numArgs: aGplToken	^ (self numPushed + (self numReturn: aGplToken)) 	-  (self notConsumedTokens: aGplToken) size	! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 5/20/2009 16:05'!numPushed	argStack ifNil: [argStack := OrderedCollection new].	^argStack size	! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 6/10/2009 16:02'!numReturn: aGplToken	(GplHandler isVoid: aGplToken fragment)		ifTrue: [^0].	^aGplToken leftTokens isEmpty		ifTrue: [0]		ifFalse: [1].	! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 5/27/2009 16:17'!popArg	| result |	argStack		ifEmpty: [self runtimeError: 'Missing argument'].	result := argStack last.	((result isKindOf: GplToken)			and: [result isVariableAllowed					and: [self hasVariableName: result fragment]])		ifTrue: [result := self variableNamed: result fragment].	argStack := argStack allButLast.	^ result! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 5/20/2009 16:23'!postfixIndexOf: aGplToken 	^postfixTokens indexOf: aGplToken.! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 5/21/2009 18:41'!pushArg: aToken	self assert: (aToken isMemberOf: GplEvaluter) not.	argStack ifNil: [argStack := OrderedCollection new].	argStack add: aToken.	! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 4/26/2009 10:33'!resolveVariableNameFromTokens: aGplTokens	GplParser assertGplTokens: aGplTokens.	^aGplTokens! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 5/29/2009 18:24'!syntaxCheck: aGplTokens	| checker |	checker := GplSyntax new.	checker model: self.	checker checkFromTokens: aGplTokens.! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 5/17/2009 14:36'!tokensFrom: aString	| tokens |	tokens := GplParser tokensFrom: aString.	(tokens select: [:each | each type = #unresolved])		do: [:each |			 (GplHandler hasCommandName: each fragment asUppercase)				ifTrue: [each type: #method]].	tokens := self resolveVariableNameFromTokens: tokens.	^tokens! !!GplEvaluter methodsFor: 'evaluter' stamp: 'kf 4/25/2009 21:40'!variableNamed: aVariableName	varMap ifNil: [varMap := Dictionary new.].	^varMap at: aVariableName ifAbsentPut: [GplVariable named: aVariableName].! !!GplEvaluter methodsFor: 'context stack' stamp: 'kf 6/6/2009 11:05'!flushContextStacks	resultMap := nil.	suspendContext  := nil.	! !!GplEvaluter methodsFor: 'context stack' stamp: 'kf 6/6/2009 09:47'!hasSuspendContext	suspendContext ifNil: [suspendContext := OrderedCollection new].	^suspendContext isEmpty not.	! !!GplEvaluter methodsFor: 'context stack' stamp: 'kf 6/6/2009 10:08'!peekSuspendContext	suspendContext ifNil: [suspendContext := OrderedCollection new].	^suspendContext last.	! !!GplEvaluter methodsFor: 'context stack' stamp: 'kf 6/6/2009 14:42'!popResult	| lastContext result |	self hasSuspendContext 		ifFalse: [^nil].			lastContext := self popSuspendContext.	result := self resultAt: lastContext.	resultMap removeKey: lastContext.	^result.	! !!GplEvaluter methodsFor: 'context stack' stamp: 'kf 6/6/2009 10:09'!popSuspendContext	| result |	suspendContext ifNil: [suspendContext := OrderedCollection new].	result := suspendContext last.	suspendContext := suspendContext allButLast.	^result.	! !!GplEvaluter methodsFor: 'context stack' stamp: 'kf 6/6/2009 11:10'!pushResult: aObject	self assert: aObject isNil not.	self hasSuspendContext 		ifTrue: [			| lastContext |			lastContext := self peekSuspendContext.			self registerResult:  aObject at:  lastContext].! !!GplEvaluter methodsFor: 'context stack' stamp: 'kf 6/6/2009 09:30'!pushSuspendContext: aContext	suspendContext ifNil: [suspendContext := OrderedCollection new].	suspendContext add: aContext.! !!GplEvaluter methodsFor: 'context stack' stamp: 'kf 6/6/2009 11:09'!registerResult: aResultValue at: aContext	self assert: (aContext isMemberOf: MethodContext).	resultMap ifNil: [resultMap := Dictionary new ].	resultMap at: aContext put: aResultValue.! !!GplEvaluter methodsFor: 'context stack' stamp: 'kf 6/6/2009 11:09'!resultAt: aContext	self assert: (aContext isMemberOf: MethodContext).	resultMap ifNil: [resultMap := Dictionary new ].	^resultMap at: aContext ! !!GplEvaluter methodsFor: 'context stack' stamp: 'kf 6/7/2009 14:11'!resume	| context suspendedToken suspendPc skippedStream |	self hasSuspendContext ifFalse: [^self].	context := self peekSuspendContext.	suspendedToken := context tempAt: 1.	suspendPc := self postfixIndexOf: suspendedToken.	skippedStream := ReadStream on: postfixTokens.	skippedStream skip: suspendPc - 1.	^self evalutePostfixStream: skippedStream.	! !!GplEvaluter methodsFor: 'analysis' stamp: 'kf 5/23/2009 19:31'!gplValueFromGplValues: aGplValues 	aGplValues size = 1 ifTrue: [^ aGplValues first].	^ GdsVector withAll: aGplValues asArray! !!GplEvaluter methodsFor: 'analysis' stamp: 'kf 4/23/2009 12:02'!handleForKey: aKey line: aString	| sel |	sel := aKey,':'.	sel := sel asSymbol.	(self class selectors includes: sel )		ifTrue: [^self perform: sel with: aString].	^'Not found: ', aKey! !!GplEvaluter methodsFor: 'analysis' stamp: 'kf 4/22/2009 21:57'!inspectConsoleLine: aString	| tokens parser |	parser := GplParser new. 	parser source: aString.	tokens :=  parser tokens .	^tokens printString.! !!GplEvaluter methodsFor: 'analysis' stamp: 'kf 4/23/2009 14:02'!lastEvalutedLine	(history isEmpty)		ifTrue: [^''] ifFalse: [^history last].! !!GplEvaluter methodsFor: 'analysis' stamp: 'kf 4/26/2009 10:22'!vectorAnalysisFromTokens: aGplTokens	| stream vectorTokens token newOutput|	self assertGplTokens: aGplTokens.	stream := ReadStream on: aGplTokens.	newOutput := OrderedCollection new.	vectorTokens := OrderedCollection new.	[stream atEnd] 		whileFalse: [			token := stream next.			(self isScalarToken: token) 				ifTrue: [.					vectorTokens add: token]				ifFalse: [					vectorTokens						ifNotEmpty: [							| newToken |							newToken := GplToken newFromTokens: vectorTokens.							newOutput add: newToken.							vectorTokens := OrderedCollection new.].					newOutput add: token]].		vectorTokens			ifNotEmpty: [				| newToken |				newToken := GplToken newFromTokens: vectorTokens.				newOutput add: newToken.				vectorTokens := OrderedCollection new.].	^newOutput asArray.! !!GplEvaluter methodsFor: 'command' stamp: 'kf 4/23/2009 14:13'!history: aInputString		| digitLength num |	digitLength := history size asString.	num := 0.		^(history collect: [:line | 		num := num + 1.		' ', num asString,' ', line]) asArray		joinUsing: String cr	! !!GplEvaluter methodsFor: 'command' stamp: 'kf 4/24/2009 13:57'!inspect: aInputString		^((self evaluteLine: aInputString)) printString.	! !!GplEvaluter methodsFor: 'command' stamp: 'kf 5/23/2009 01:11'!inspectPostfix: aInputString		^(self translateToPostfix: aInputString)printString	! !!GplEvaluter methodsFor: 'command' stamp: 'kf 4/23/2009 14:22'!inspectToken: aInputString		^(GplParser splitTokens: aInputString) printString.	! !!GplEvaluter methodsFor: 'command' stamp: 'kf 4/26/2009 10:38'!inspectTokens: aInputString		^(self tokensFrom: aInputString) printString.	! !!GplEvaluter methodsFor: 'command' stamp: 'kf 5/23/2009 01:10'!postfix: aInputString		^((self translateToPostfix: aInputString) collect: [:token | token postfixExpr ]) printString	! !!GplEvaluter methodsFor: 'command' stamp: 'kf 4/23/2009 17:45'!tokens: aInputString		^((GplParser tokensFrom: aInputString) collect: [:token | token fragment]) asArray printString.	! !!GplEvaluter methodsFor: 'initialization' stamp: 'kf 5/21/2009 18:14'!initialize	super initialize.	history := OrderedCollection new.	showsLog := false.	! !!GplEvaluter methodsFor: 'testing' stamp: 'kf 5/18/2009 13:25'!isDefined: aWord	aWord = #cr ifTrue: [^true].	aWord trimBlanks ifEmpty: [^true].	(self hasVariableName: aWord) ifTrue: [^true]. 	^self isOperator: aWord.! !!GplEvaluter methodsFor: 'testing' stamp: 'kf 5/22/2009 13:54'!isDyadic: aGplTokenOrString	| fragment |	(self isOperator: aGplTokenOrString) ifFalse: [^false].	fragment := (aGplTokenOrString isKindOf: GplToken)		ifTrue: [aGplTokenOrString fragmentForInspect]		ifFalse: [aGplTokenOrString].		(fragment endsWith: '(dyadic)')		ifTrue: [^true].	^#(RESHAPE ':=') includes: fragment.	! !!GplEvaluter methodsFor: 'testing' stamp: 'kf 4/25/2009 17:15'!isInteractive	^true! !!GplEvaluter methodsFor: 'testing' stamp: 'kf 5/23/2009 11:58'!isNumber: aString		^GplParser isNumberFragment: aString	.! !!GplEvaluter methodsFor: 'testing' stamp: 'kf 4/26/2009 11:32'!isOperandToken: aGplToken	^#(number string vector unresolved) includes: aGplToken type	! !!GplEvaluter methodsFor: 'testing' stamp: 'kf 5/23/2009 11:46'!isOperator: aGplTokenOrString	^(GplPostfix isOperator: aGplTokenOrString).! !!GplEvaluter methodsFor: 'testing' stamp: 'kf 4/26/2009 10:21'!isScalarToken: aGplToken	(self isVariableRegistered: aGplToken fragment)		ifTrue: [			^(self variableNamed: aGplToken fragment) rank = 0].	^aGplToken type = #number	! !!GplEvaluter methodsFor: 'testing' stamp: 'kf 4/25/2009 15:42'!isVariableRegistered: aWord	^false	! !!GplEvaluter methodsFor: 'debug' stamp: 'kf 5/22/2009 13:41'!printArgStack: aToken	argStack ifNil: [^self].	Transcript cr; show: (aToken -> argStack).! !!GplEvaluter methodsFor: 'analysis-postfix' stamp: 'kf 5/23/2009 11:46'!translateToPostfix: aSourceCode	^GplPostfix new translateToPostfixFromTokens: (self tokensFrom: aSourceCode) ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplEvaluter class	instanceVariableNames: ''!!GplEvaluter class methodsFor: 'as yet unclassified' stamp: 'kf 5/26/2009 17:05'!arithmeticSelector: aGplToken 	| sel |	sel := aGplToken fragment asSymbol.	^ sel = #% ifTrue: [#/] ifFalse: [sel]! !!GplEvaluter class methodsFor: 'as yet unclassified' stamp: 'kf 4/26/2009 12:50'!debugEvalute: aGplExpression	|result|	Transcript cr; show: '? ', aGplExpression.	[result := self new evaluteConsoleLine: aGplExpression.	Transcript cr; show: result]	on: Error do: [:ex | Transcript cr; show: ex messageText]! !GplTokenHandler subclass: #GplPostfix	instanceVariableNames: 'outTokens'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Kernel'!!GplPostfix methodsFor: 'analysis-postfix' stamp: 'kf 5/29/2009 23:46'!gotOperator: aToken	| done |	self precedenceOf: aToken.	done := false.	[stack isEmpty or: [done]]		whileFalse: [			| topToken |			topToken := self pop.			(topToken fragment = '(' or: [topToken fragment = '['])				ifTrue: [self push: topToken. done := true]				ifFalse: [					((self precedenceOf: topToken) < (self precedenceOf: aToken))						ifTrue: [self push: topToken. done := true]						ifFalse: [outTokens add: topToken]]].	self push: aToken.! !!GplPostfix methodsFor: 'analysis-postfix' stamp: 'kf 5/22/2009 22:52'!gotParen: aToken	| done |	done := false.	[stack isEmpty or: [done]]		whileFalse: [			| topToken |			topToken := self pop.			topToken fragment = '('				ifTrue: [done := true.]				ifFalse: [outTokens add: topToken]]! !!GplPostfix methodsFor: 'analysis-postfix' stamp: 'kf 6/8/2009 16:55'!gotSlice: aToken	| done |	done := false.	[stack isEmpty or: [done]]		whileFalse: [			| topToken |			topToken := self pop.			outTokens add: topToken.			topToken fragment = '['				ifTrue: [					done := true.]]! !!GplPostfix methodsFor: 'analysis-postfix' stamp: 'kf 5/22/2009 22:52'!guessAgumentType: aToken monadicBlock: aMonadicBlock dyadicBlock: aDyadicBlock	| leftTokens |	leftTokens := aToken leftTokens.	"leftTokens explore."	leftTokens ifNotEmpty: [		(self returnValueEnabled: leftTokens last)			ifTrue: [				aToken  argumentType:  #dyadic.				^aDyadicBlock value]].	aToken  argumentType: #monadic.	^aMonadicBlock value.	! !!GplPostfix methodsFor: 'analysis-postfix' stamp: 'kf 5/29/2009 22:46'!operatorSwitch: aGplToken	(aGplToken fragment = ':=')		ifTrue: [self push: aGplToken. ^self].	(aGplToken fragment = '(')		ifTrue: [self push: aGplToken. ^self].	(aGplToken fragment = '[')		ifTrue: [self push: aGplToken. ^self].	(aGplToken fragment = ')')		ifTrue: [self gotParen: aGplToken. ^self].	(aGplToken fragment = ']')		ifTrue: [self gotSlice: aGplToken. ^self].	(self class isOperator: aGplToken fragment)		ifTrue: [self gotOperator: aGplToken. ^self].	outTokens add: aGplToken.	^self.	! !!GplPostfix methodsFor: 'analysis-postfix' stamp: 'kf 9/8/2012 17:14'!precedenceOf: aToken	GplParser operatorSpec do: [:assoc |		(assoc value includes: aToken fragment asUppercase)			ifTrue: [^assoc key]].	aToken fragment size = 1		ifTrue: [			('[]' includes: aToken fragment first)				ifTrue: [^377].			('*%' includes: aToken fragment first)				ifTrue: [					^self 						guessAgumentType: aToken 						monadicBlock: [20] 						dyadicBlock: [16]].			('+-' includes: aToken fragment first)				ifTrue: [					^self 						guessAgumentType: aToken 						monadicBlock: [20] 						dyadicBlock: [15]].			(',' includes: aToken fragment first)				ifTrue: [					^self 						guessAgumentType: aToken 						monadicBlock: [10] 						dyadicBlock: [6]]].	(GplBiContextHandler hasCommandName: aToken fragment)		ifTrue: [aToken isProcedureCall ifTrue: [^-1]].	(GplHandler isVoid: aToken fragment)		ifTrue: [^-1].	^555! !!GplPostfix methodsFor: 'analysis-postfix' stamp: 'kf 5/22/2009 22:52'!returnValueEnabled: aToken	('([' includes: aToken fragment first)		ifTrue: [^false].	(')]' includes: aToken fragment first)		ifTrue: [^true].	(GplHandler noArgReturnValueEnabled: aToken fragment)		ifTrue: [^true].	^aToken isOperator not! !!GplPostfix methodsFor: 'analysis-postfix' stamp: 'kf 5/29/2009 11:23'!translateToPostfixFromTokens: aGplTokens	self beforeEvaluteTokens: aGplTokens.	outTokens := OrderedCollection new.	aGplTokens do: [:token |		self operatorSwitch: token].	[stack isEmpty]		whileFalse: [outTokens add: self pop].	^outTokens asArray.! !!GplPostfix methodsFor: 'initialize-release' stamp: 'kf 5/29/2009 11:15'!initialize	super initialize.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplPostfix class	instanceVariableNames: ''!!GplPostfix class methodsFor: 'as yet unclassified' stamp: 'kf 5/23/2009 11:56'!isOperator: aGplTokenOrString	| fragment |	fragment := (aGplTokenOrString isKindOf: GplToken)		ifTrue: [aGplTokenOrString fragment]		ifFalse: [aGplTokenOrString].		(GplHandler hasCommandName: (fragment asUppercase)) ifTrue: [^true].	^(GplParser isOperatorFragment: fragment).! !GplTokenHandler subclass: #GplSyntax	instanceVariableNames: 'model'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Kernel'!!GplSyntax commentStamp: 'kf 5/29/2009 12:01' prior: 0!A GplSyntax is GPLII syntax checker.Instance Variables!!GplSyntax methodsFor: 'private check' stamp: 'kf 5/29/2009 18:44'!assignCheck: aGplTokens	| assignToken leftTokens keywordToken |	assignToken := aGplTokens detect: [:each | each fragment = ':='] ifNone: [nil].	assignToken ifNil: [^self].	leftTokens := self leftCheckFor: assignToken.	self rightCheckFor: assignToken.	keywordToken := leftTokens detect: [:each | 		GplHandler hasCommandName: each fragment] ifNone: [nil].	keywordToken 		ifNotNil: [			^self				syntaxError: 'VARIABLE CAN''T ASSIGND TO PROCEDURE OR FUNCTION'				token: keywordToken]! !!GplSyntax methodsFor: 'private check' stamp: 'kf 5/29/2009 17:27'!cantUseCheck: aGplTokens 	self isInteractive ifFalse: [^self].		aGplTokens do: [:each |		(GplToken isProgramOnlyKeyword: each fragment )				ifTrue: [^self syntaxError: 'KEYWORD NOT LEAGAL IN THIS CONTEXT' token: each]].! !!GplSyntax methodsFor: 'private check' stamp: 'kf 5/29/2009 11:45'!declareCheck: aGplTokens	self methodDeclareCheck: aGplTokens.	self variableDeclareCheck: aGplTokens.		! !!GplSyntax methodsFor: 'private check' stamp: 'kf 5/29/2009 16:21'!depthCheck: aGplTokens 	self parlenDepthCheck: aGplTokens.	self subscriptDepthCheck: aGplTokens.	self 		missMatchCheck: aGplTokens 		openFragments: { '(' . '[' } closeFragments: { ')' . ']' }! !!GplSyntax methodsFor: 'private check' stamp: 'kf 5/29/2009 20:31'!leftCheckFor: anAssignToken	| leftTokens expressionToken |	leftTokens := anAssignToken leftTokens		select: [:each | each depthOfSubscript = anAssignToken depthOfSubscript].	expressionToken := leftTokens		 detect: [:each | each fragment =')'] ifNone: [nil].	expressionToken		ifNotNil: [^self syntaxError: 'ILLIGAL STORE OPERATION'].			leftTokens := anAssignToken leftTokensOfSameDepth .	leftTokens		ifEmpty: [^self syntaxError: 'MISSING LEFT VARIABLE FOR' token: anAssignToken].	^leftTokens! !!GplSyntax methodsFor: 'private check' stamp: 'kf 5/29/2009 20:41'!methodDeclareCheck: aGplTokens	| voidToken voidTokens |	voidTokens := aGplTokens		select: [:each | 			each fragment first isLetter 			and: [ (self hasVariableName:  each fragment) not]			and: [ GplHandler isVoid: each fragment]].	voidTokens ifEmpty: [^self].	voidToken := voidTokens first.	voidToken leftTokens isEmpty 		ifFalse: [			^self 				syntaxError: 'NOT A VALUEABLE PROCEDURE CALL'  token: voidToken].	! !!GplSyntax methodsFor: 'private check' stamp: 'kf 5/29/2009 18:00'!numberLiteralCheck: aGplTokens	| unresolvedTokens |	unresolvedTokens := aGplTokens select: [:each | 			each type =  #unresolved 		and: [(GplParserBase isNameFirst: each fragment first) not]		and: [GplParser isNumberFragment: each fragment]].	unresolvedTokens ifEmpty: [^self].			^self 		syntaxError: 'INVALID NUMERIC FORMAT'		token: unresolvedTokens first.! !!GplSyntax methodsFor: 'private check' stamp: 'kf 5/29/2009 16:04'!parlenDepthCheck: aGplTokens 	| emptyToken |	self betweenCheck:  aGplTokens openFragment:  '(' closeFragment:  ')' .	emptyToken := self insideEmptyCheck: aGplTokens openFragment:  '('  closeFragment:  ')'.	emptyToken		ifNotNil: [^self syntaxError: 'EMPTY EXPRESSION ()'].! !!GplSyntax methodsFor: 'private check' stamp: 'kf 6/5/2009 11:08'!rightCheckFor: anAssignToken	| rightTokens voidToken |			rightTokens := anAssignToken rightTokens.	rightTokens		ifEmpty: [^self syntaxError: 'MISSING RIGHT EXPRESSION FOR' token: anAssignToken].	voidToken := anAssignToken 		rightTokens			detect: [:each | 				each type ~= #number				and: [each fragment first isLetter ]				and: [ (self hasVariableName:  each fragment) not]				and: [GplHandler isVoid: each fragment]] 			ifNone: [nil].	voidToken		ifNotNil: [			^self 				syntaxError: 'NOT A VALUEABLE PROCEDURE CALL' 				token: voidToken ].! !!GplSyntax methodsFor: 'private check' stamp: 'kf 5/29/2009 16:05'!subscriptDepthCheck: aGplTokens 	| emptyToken |	self betweenCheck:  aGplTokens openFragment:  '[' closeFragment:  ']'.	emptyToken := self insideEmptyCheck: aGplTokens openFragment:  '['  closeFragment:  ']'.	emptyToken		ifNotNil: [^self syntaxError: 'EMPTY SUBSCRIPT EXPRESSION []'].	 			! !!GplSyntax methodsFor: 'private check' stamp: 'kf 5/29/2009 17:46'!variableDeclareCheck: aGplTokens	"allow undefined "	"left operand and isInteractive"	| unresolvedTokens |	unresolvedTokens := aGplTokens select: [:each | 		each type =  #unresolved and: [(self isDefined: each fragment) not]].	unresolvedTokens ifEmpty: [^self].	self isInteractive		ifFalse: [			^self 				syntaxError: 'VARIABLE NOT DEFINED'				token: unresolvedTokens first].		unresolvedTokens do: [:each |		(each rightTokens isEmpty not 				and: [each rightTokens first fragment = ':='])			ifFalse: [				^self 					syntaxError: 'VARIABLE NOT DEFINED'					token: each]].! !!GplSyntax methodsFor: 'private' stamp: 'kf 5/29/2009 18:43'!betweenCheck: aGplTokens openFragment: aOpenFragment closeFragment: aCloseFragment	| openParlens closeParlens |	openParlens := aGplTokens select: [:each | each fragment = aOpenFragment].	closeParlens := aGplTokens select: [:each | each fragment = aCloseFragment].	(openParlens size + closeParlens size) = 0 ifTrue: [^self.].	(openParlens size > closeParlens size)		ifTrue: [^self syntaxError: ('EXTRA ') token: openParlens first].	(openParlens size < closeParlens size)		ifTrue: [^self syntaxError: ('EXTRA ') token: closeParlens last.]		! !!GplSyntax methodsFor: 'private' stamp: 'kf 5/29/2009 16:05'!insideEmptyCheck: aGplTokens openFragment: aOpenFragment closeFragment: aCloseFragment	| openParlens |	openParlens := aGplTokens select: [:each | each fragment = aOpenFragment].	openParlens do: [:each |		|rightTokens |		rightTokens := each rightTokens.		rightTokens			ifNotEmpty: [				(rightTokens first fragment = aCloseFragment)					ifTrue: [^each]]].	^nil.! !!GplSyntax methodsFor: 'private' stamp: 'kf 6/8/2009 16:39'!missMatchCheck: aGplTokens openFragments: aOpenFragments closeFragments: aCloseFragments	| topToken |	self resetStack.	aGplTokens		do: [:each |			each fragment = aOpenFragments first				ifTrue: [self push: each].			each fragment = aOpenFragments second				ifTrue: [self push: each].				each fragment = aCloseFragments first				ifTrue: [					topToken := self pop.					topToken fragment = aOpenFragments first						ifFalse: [							^self 								syntaxError: 'MISS MATCH MUST: ', aCloseFragments second, ' BUT'								token: each].].			each fragment = aCloseFragments second				ifTrue: [					topToken := self pop.					topToken fragment = aOpenFragments second						ifFalse: [							^self								syntaxError: ('MISS MATCH MUST: ', aCloseFragments first, ' BUT')								token: each].].]				! !!GplSyntax methodsFor: 'private' stamp: 'kf 5/29/2009 17:18'!syntaxError: aMessage token: aGplToken	^self syntaxError: (self syntaxMessage: aMessage token: aGplToken)! !!GplSyntax methodsFor: 'check' stamp: 'kf 5/29/2009 17:59'!checkFromTokens: aGplTokens 	self beforeEvaluteTokens: aGplTokens.	self depthCheck: aGplTokens.	self numberLiteralCheck: aGplTokens.	self declareCheck: aGplTokens.	self assignCheck: aGplTokens.	self cantUseCheck: aGplTokens.	! !!GplSyntax methodsFor: 'testing' stamp: 'kf 5/29/2009 20:36'!hasVariableName: aWord	model ifNil: [^false].	^model hasVariableName: aWord! !!GplSyntax methodsFor: 'testing' stamp: 'kf 5/29/2009 17:36'!isDefined: aWord	model ifNil: [^false].	^model isDefined: aWord! !!GplSyntax methodsFor: 'testing' stamp: 'kf 5/29/2009 17:21'!isInteractive	model ifNil: [^true].	^model isInteractive! !!GplSyntax methodsFor: 'accessing' stamp: 'kf 5/29/2009 18:09'!model: aModel	model := aModel! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplSyntax class	instanceVariableNames: ''!!GplSyntax class methodsFor: 'as yet unclassified' stamp: 'kf 5/29/2009 15:54'!check: aString	| tokens |	tokens := GplParser tokensFrom: aString.	self new checkFromTokens: tokens.	! !GdsDataStructure subclass: #GplVariable	instanceVariableNames: 'varName gplValue'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsCompiler-Kernel'!!GplVariable commentStamp: 'kf 4/21/2009 23:50' prior: 0!A GplVariable is assigneable Variable in GDSII.Instance Variables	varName:		<String>varName	- unique name in GPL evaluter memory space.	- regex: '^[A-Z$][A-Z0-9$_]*$' max 32byte!!GplVariable methodsFor: 'accessing' stamp: 'kf 4/25/2009 23:47'!asGplValue	^gplValue! !!GplVariable methodsFor: 'accessing' stamp: 'kf 4/25/2009 21:37'!gplValue: aGdsDataStructure	gplValue := aGdsDataStructure.! !!GplVariable methodsFor: 'accessing' stamp: 'kf 4/25/2009 23:24'!name	^varName	! !!GplVariable methodsFor: 'accessing' stamp: 'kf 4/21/2009 23:44'!name: aVariableName	varName := aVariableName.! !!GplVariable methodsFor: 'accessing' stamp: 'kf 4/25/2009 22:56'!rank	^gplValue rank! !!GplVariable methodsFor: 'convert' stamp: 'kf 4/25/2009 22:14'!asSmalltalkValue	^gplValue asSmalltalkValue.! !!GplVariable methodsFor: 'error handling' stamp: 'kf 4/25/2009 22:13'!doesNotUnderstand: aMessage	gplValue perform: aMessage selector withArguments: aMessage arguments.! !!GplVariable methodsFor: 'testing' stamp: 'kf 4/25/2009 22:16'!isVariableAllowed	^true! !!GplVariable methodsFor: 'printing' stamp: 'kf 4/25/2009 23:02'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('.	aStream nextPutAll: varName.	aStream nextPutAll: ','.	aStream nextPutAll: gplValue gplString.		aStream nextPutAll: ')'.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GplVariable class	instanceVariableNames: ''!!GplVariable class methodsFor: 'as yet unclassified' stamp: 'kf 4/26/2009 12:49'!named: aVariableName	^self new name: aVariableName.! !