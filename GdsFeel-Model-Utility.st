Object subclass: #GdsColorUtils	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Utility'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GdsColorUtils class	instanceVariableNames: ''!!GdsColorUtils class methodsFor: 'as yet unclassified' stamp: 'kf 11/7/2009 18:50'!fromAttributes: aDictionary 	| a r g b |	a := aDictionary at: 'a' ifAbsent: [1.0].			r := aDictionary at: 'r' ifAbsent: [1.0].			g := aDictionary at: 'g' ifAbsent: [1.0].			b := aDictionary at: 'b' ifAbsent: [1.0].	^Color r: r g: g b: b alpha: a. 										! !!GdsColorUtils class methodsFor: 'as yet unclassified' stamp: 'kf 11/7/2009 22:22'!rgbaAttributesOn: aDictionary color: aColor	aDictionary at: 'r' put: aColor red asString.	aDictionary at: 'g' put: aColor green asString.	aDictionary at: 'b' put: aColor blue asString.	aDictionary at: 'a' put: aColor alpha asString.	 ! !INIFile subclass: #GdsIniFile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Utility'!!GdsIniFile methodsFor: 'writing' stamp: 'kf 6/16/2009 13:19'!writeOn: aStream	self sections		do: [:ea | ea writeOn: aStream]		separatedBy: [			aStream cr. 			aStream nextPut: Character lf]! !INIFileSection subclass: #GdsIniFileSecion	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Utility'!!GdsIniFileSecion methodsFor: 'private' stamp: 'kf 6/14/2009 21:15'!writeOn: aStream	aStream nextPutAll: '[', self label, ']'; cr.	aStream nextPut: Character lf.	self associationsDo:		[:assoc | 			aStream nextPutAll: assoc key, '=', (assoc value ifNil: ['']); cr.			aStream nextPut: Character lf.]! !Object subclass: #GeometryUtils	instanceVariableNames: ''	classVariableNames: 'Degree45Theta Pi2'	poolDictionaries: ''	category: 'GdsFeel-Model-Utility'!!GeometryUtils methodsFor: 'look in class' stamp: 'kf 10/25/2008 08:58'!seeClassSide	"All the code for GeometryUtils is on the class side"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GeometryUtils class	instanceVariableNames: ''!!GeometryUtils class methodsFor: 'as yet unclassified' stamp: 'kf 11/5/2008 16:18'!asCirculerIndex: segIndex segments: segs	| index |	index := segIndex \\ segs size. 	index = 0 ifTrue: [index := segs size].	self assert: [index between: 1 and: segs size].	^index! !!GeometryUtils class methodsFor: 'as yet unclassified' stamp: 'kf 10/3/2008 21:44'!initialize	"GeometryUtils initialize"	super initialize.	Degree45Theta := (Float pi / 4.0).	Pi2 := (Float pi * 2.0).		! !!GeometryUtils class methodsFor: 'as yet unclassified' stamp: 'kf 11/17/2009 20:24'!limitedPoint: aPoint	| x y |	x := aPoint x < 0 		ifTrue: [aPoint x max:  -32768]		ifFalse: [aPoint x min:  32767].	y := aPoint y < 0 		ifTrue: [aPoint y max:  -32768]		ifFalse: [aPoint y min:  32767].	^x@y.	! !!GeometryUtils class methodsFor: 'as yet unclassified' stamp: 'kf 9/30/2008 23:04'!lineSegmentsFormPointArray: aPointArray	| col |	col := OrderedCollection new.	self pointArray: aPointArray lineSegmentsDo: [ :seg |		col add: seg].	^col asArray.! !!GeometryUtils class methodsFor: 'as yet unclassified' stamp: 'kf 11/5/2008 17:10'!lookupDataBounds: vertices	| minX minY maxX maxY |	minX := SmallInteger maxVal.	minY := SmallInteger maxVal.	maxX := SmallInteger minVal.	maxY := SmallInteger minVal.	vertices do: 		[ :p | 		minX := minX min: p x.		minY := minY min: p y.		maxX := maxX max: p x.		maxY := maxY max: p y ].	^ minX @ minY corner: maxX @ maxY! !!GeometryUtils class methodsFor: 'as yet unclassified' stamp: 'kf 9/17/2008 22:43'!midPointP1: pt1 p2: pt2	^(pt1 + pt2) / 2.0.! !!GeometryUtils class methodsFor: 'as yet unclassified' stamp: 'kf 9/11/2008 21:39'!minusBounds	^Rectangle 		origin: (SmallInteger maxVal@SmallInteger maxVal) 		corner: (SmallInteger minVal@SmallInteger minVal).! !!GeometryUtils class methodsFor: 'as yet unclassified' stamp: 'kf 10/3/2008 21:47'!octagonalRoundTheta: aTheta	| ratio roundedRatio |	ratio := aTheta / Pi2.	roundedRatio := ratio roundTo: 0.125.	^Pi2 * roundedRatio.! !!GeometryUtils class methodsFor: 'as yet unclassified' stamp: 'kf 11/17/2009 20:24'!point: aPoint roundTo: grid	"Answer a Point that is the receiver's x and y rounded to grid x and 	grid y."		| gridPoint nX nY |	gridPoint := grid asPoint.	nX := aPoint x copy.	nY := aPoint y copy.	gridPoint x asFloat = 0.0 		ifFalse: [nX := aPoint x roundTo: gridPoint x].	gridPoint y asFloat = 0.0 		ifFalse: [nY := aPoint y roundTo: gridPoint y].	^nX@nY! !!GeometryUtils class methodsFor: 'as yet unclassified' stamp: 'kf 9/30/2008 22:59'!pointArray: aPointArray lineSegmentsDo: aLineSegmentBlock	| p1 p2 segment |	aPointArray size < 2 ifTrue: [^self].	1 to: aPointArray size -1 do: [ :index |		p1 := aPointArray at: index.		p2 := aPointArray at: index + 1.		segment := LineSegment from: p1 to: p2.		aLineSegmentBlock value: segment]. ! !!GeometryUtils class methodsFor: 'as yet unclassified' stamp: 'kf 9/12/2008 14:51'!reducedPoints: aLength p1: pt1 p2: pt2	| deltaPoint theta dx dy |	deltaPoint := pt2 - pt1.	theta := deltaPoint theta.	dx := theta cos * aLength.	dy := theta sin *aLength.	^{pt1 + (dx@dy) . pt2 - (dx@dy) }! !!GeometryUtils class methodsFor: 'as yet unclassified' stamp: 'kf 10/28/2009 11:35'!removeDuplicatePoints: aPointArray on: aOrderedCollection	| prevPoint |	prevPoint := nil.	aPointArray do: [:each |		prevPoint 			ifNil: [aOrderedCollection add: each]			ifNotNil: [				prevPoint = each					ifFalse: [aOrderedCollection add: each]]. 		prevPoint := each.]! !!GeometryUtils class methodsFor: 'as yet unclassified' stamp: 'kf 11/27/2008 23:30'!verticesFromBounds: aBounds	^{		aBounds origin x @ aBounds origin y .		aBounds origin x @ aBounds corner y .		aBounds corner x @ aBounds corner y .		aBounds corner x @ aBounds origin y .		aBounds origin x @ aBounds origin y}.		! !!GeometryUtils class methodsFor: 'analisys-linesegment' stamp: 'kf 11/5/2008 10:44'!analisysSegmentsAt: aPoint pointArray: vertices 	| maps infos minSegIndex result minInfo|	maps := self segmentDistanceMaps: aPoint pointArray: vertices.	infos := maps collect: [:each | self nearyInfoOfDistanceMap:  each ].	minInfo := (infos sort: [:a :b | a second  < b second ]) first.	minSegIndex := minInfo last at: #segIndex.	infos := infos sort: [:a :b | (a third at: #segIndex) < (b third at: #segIndex) ].	result := Dictionary new.	result at: #index put: minSegIndex.	result at: #infos put: infos.	result at: #element put: self.	result at: #testPoint put: aPoint.	^result.! !!GeometryUtils class methodsFor: 'analisys-linesegment' stamp: 'kf 7/13/2009 16:06'!distanceMapAt: aPoint segment: aLineSegment	| distanceMap  p distP |	distanceMap := Dictionary new.	distanceMap at: #seg put: aLineSegment.	p := aPoint nearestPointAlongLineFrom: aLineSegment start to: aLineSegment end.	distanceMap at: #virtualCrossPoint put: p copy.		p := (distanceMap at: #virtualCrossPoint) 				adhereTo: (aLineSegment bounds).	distanceMap at: #crossPoint put: p copy.	distP := p dist: aPoint.	distanceMap at: #cross put: distP copy.	distP := aLineSegment start dist: aPoint.	distanceMap at: #start put: distP copy.	distP := aLineSegment start dist: (distanceMap at: #crossPoint).	distanceMap at: #startToCross put: distP copy.	distP := aLineSegment end dist: aPoint.	distanceMap at: #end put: distP copy.	distP := aLineSegment end dist: (distanceMap at: #crossPoint).	distanceMap at: #endToCross put: distP copy.	distanceMap at: #side put: (aLineSegment sideOfPoint: aPoint).	^distanceMap.! !!GeometryUtils class methodsFor: 'analisys-linesegment' stamp: 'kf 7/13/2009 12:23'!distanceMapAt: aPoint segment: aLineSegment index: segIndex	| distanceMap  |	distanceMap := self distanceMapAt:  aPoint segment: aLineSegment.	distanceMap at: #segIndex put: segIndex.	^distanceMap.! !!GeometryUtils class methodsFor: 'analisys-linesegment' stamp: 'kf 7/15/2009 15:41'!lookupVertexIndex: anAlisysResult	| segInfo distanceMap segIndex whichSide |	segIndex := anAlisysResult at: #index.	segInfo := (anAlisysResult at: #infos) at: segIndex.	distanceMap := segInfo last.	whichSide := segInfo first.	(#cross == whichSide)		ifTrue: [			whichSide := 				((distanceMap at: #startToCross) <= (distanceMap at: #endToCross))					ifTrue:[#start] ifFalse:[#end]].	^(#start == whichSide) 		ifTrue: [segIndex] ifFalse:[segIndex + 1].! !!GeometryUtils class methodsFor: 'analisys-linesegment' stamp: 'kf 11/5/2008 10:41'!nearyInfoOfDistanceMap: aDictionary	| infos sortItemBlock |	sortItemBlock := [:map :sel | {sel . map at: sel . map} ].	((aDictionary at: #start) = (aDictionary at: #cross)) 		ifTrue: [^sortItemBlock value: aDictionary value: #start].	((aDictionary at: #end) = (aDictionary at: #cross)) 		ifTrue: [^sortItemBlock value: aDictionary value: #end].	infos := (aDictionary keys select: [:each | 		{#start . #end . #cross } includes: each]) asArray 			collect: [:key | sortItemBlock value: aDictionary value: key] .	^(infos sort: [:a :b | a second < b second]) first. 	! !!GeometryUtils class methodsFor: 'analisys-linesegment' stamp: 'kf 7/13/2009 12:24'!segmentDistanceMaps: aPoint pointArray: vertices 	| col segIndex |	col := OrderedCollection new.	segIndex := 0.	GeometryUtils 		pointArray:  vertices		lineSegmentsDo: [ :lineSegment | 						| distanceMap |			segIndex := segIndex + 1.			distanceMap := self distanceMapAt: aPoint segment: lineSegment index: segIndex.						col add: distanceMap ].	^ col asArray.! !Object subclass: #TypedConfigulation	instanceVariableNames: 'booleanMap numberMap pointMap stringMap'	classVariableNames: ''	poolDictionaries: ''	category: 'GdsFeel-Model-Utility'!!TypedConfigulation methodsFor: 'as yet unclassified' stamp: 'kf 11/2/2009 11:04'!booleanFor: aSymbol	^self booleanFor: aSymbol default: false.! !!TypedConfigulation methodsFor: 'as yet unclassified' stamp: 'kf 11/2/2009 11:03'!booleanFor: aSymbol default: aValue	booleanMap ifNil: [booleanMap := Dictionary new].	^booleanMap at: aSymbol ifAbsentPut: [aValue].! !!TypedConfigulation methodsFor: 'as yet unclassified' stamp: 'kf 11/2/2009 11:04'!booleanFor: aSymbol value: aBoolean	booleanMap ifNil: [booleanMap := Dictionary new].	booleanMap at: aSymbol put: aBoolean.! !!TypedConfigulation methodsFor: 'as yet unclassified' stamp: 'kf 11/2/2009 11:06'!numberFor: aSymbol	^self numberFor: aSymbol default: 0.! !!TypedConfigulation methodsFor: 'as yet unclassified' stamp: 'kf 11/2/2009 11:05'!numberFor: aSymbol default: aValue	numberMap ifNil: [numberMap := Dictionary new].	^numberMap at: aSymbol ifAbsentPut: [aValue].! !!TypedConfigulation methodsFor: 'as yet unclassified' stamp: 'kf 11/14/2009 15:47'!numberFor: aSymbol value: aNumber	self assert: [aNumber isNumber].	numberMap ifNil: [numberMap := Dictionary new].	numberMap at: aSymbol put: aNumber.! !!TypedConfigulation methodsFor: 'as yet unclassified' stamp: 'kf 11/2/2009 11:11'!pointFor: aString 	^self pointFor: aString default: 0@0 copy! !!TypedConfigulation methodsFor: 'as yet unclassified' stamp: 'kf 11/2/2009 11:08'!pointFor: aString default: aValue 	pointMap ifNil: [ pointMap := Dictionary new ].	^ pointMap 		at: aString		ifAbsentPut: [ aValue ]! !!TypedConfigulation methodsFor: 'as yet unclassified' stamp: 'kf 11/2/2009 11:08'!pointFor: aString value: aPoint 	pointMap ifNil: [ pointMap := Dictionary new ].	pointMap 		at: aString		put: aPoint! !!TypedConfigulation methodsFor: 'as yet unclassified' stamp: 'kf 11/2/2009 11:11'!stringFor: aSymbol 	^self stringFor:  aSymbol default: ''.! !!TypedConfigulation methodsFor: 'as yet unclassified' stamp: 'kf 11/2/2009 11:09'!stringFor: aSymbol default: aValue	stringMap ifNil: [stringMap := Dictionary new].	^stringMap at: aSymbol ifAbsentPut: [aValue].! !!TypedConfigulation methodsFor: 'as yet unclassified' stamp: 'kf 11/2/2009 11:10'!stringFor: aSymbol value: aBoolean	stringMap ifNil: [stringMap := Dictionary new].	stringMap at: aSymbol put: aBoolean.! !GeometryUtils initialize!